<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="iOS开发者，爱生活，爱编程">
<meta property="og:type" content="website">
<meta property="og:title" content="安东的博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="安东的博客">
<meta property="og:description" content="iOS开发者，爱生活，爱编程">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="安东的博客">
<meta name="twitter:description" content="iOS开发者，爱生活，爱编程">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>安东的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">安东的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不忘初心，方得始终</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/15/iOS-OpenGL-ES入门教程（三）纹理取样，混合，多重纹理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ace Dong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安东的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/15/iOS-OpenGL-ES入门教程（三）纹理取样，混合，多重纹理/" itemprop="url">iOS-OpenGL-ES入门教程（三）纹理取样，混合，多重纹理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-15T22:08:05+08:00">
                2018-05-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上两篇文章里我们分别绘制了最简单的三角形和纹理图片<br>下面来讲一下纹理取样，混合，和多重纹理</p>
<h1 id="纹理取样，循环"><a href="#纹理取样，循环" class="headerlink" title="纹理取样，循环"></a>纹理取样，循环</h1><p>示例代码来源于下面这本书，<br><a href="https://book.douban.com/subject/24849591/" target="_blank" rel="noopener">OpenGL ES应用开发实践指南：iOS卷</a></p>
<p>纹理取样设置函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER, GL_NEAREST)</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure>
<p><code>GL_TEXTURE_MAG_FILTER</code>用于多个纹素对应一个顶点即片元时候的处理方式，<code>GL_NEAREST</code>是取最近的纹素，<code>GL_LINEAR</code>则是取这多个纹素的混合结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure>
<p> <code>GL_TEXTURE_MAG_FILTER</code>参数用于没有足够的可用纹素来唯一性的映射一个或者多个纹素到每个片元时配置取样. GL_NEAREST是取最近的纹素，GL_LINEAR则是取附近多个纹素的混合结果<br>GL_LINEAR的直观显示效果就是图片模糊的渲染了。</p>
<p>我们知道顶点的坐标系U,V坐标和纹理的S,T坐标一一映射对用，如果U，V大于1，或者小于0，也就是超出了纹理坐标系，我们可以设置取样边缘的纹素，或者重复纹理取样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);//取样纹理边缘的纹素</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);//重复纹理填满</span><br><span class="line">    </span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);//取样纹理边缘的纹素</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);//重复纹理填满</span><br></pre></td></tr></table></figure>
<p>接下来我们用下面这个Demo来看下实际效果<br><img src="https://upload-images.jianshu.io/upload_images/1320629-95f28b236f2535c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Demo.png"></p>
<p>这里列举下核心代码</p>
<p>首先是顶点数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    GLKVector3 positionCoords;</span><br><span class="line">    GLKVector2 textureCoord;</span><br><span class="line">&#125;SceneVertex;</span><br><span class="line"></span><br><span class="line">//顶点 三角形 </span><br><span class="line">static SceneVertex vertices[] =</span><br><span class="line">&#123;</span><br><span class="line">    &#123;&#123;-0.5f, -0.5f, 0.0f&#125;, &#123;0.0f, 0.0f&#125;&#125;, // lower left corner</span><br><span class="line">    &#123;&#123; 0.5f, -0.5f, 0.0f&#125;, &#123;1.0f, 0.0f&#125;&#125;, // lower right corner</span><br><span class="line">    &#123;&#123;-0.5f,  0.5f, 0.0f&#125;, &#123;0.0f, 1.0f&#125;&#125;, // upper left corner</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//默认顶点 -- 用于关闭动画时候恢复默认顶点</span><br><span class="line">static const SceneVertex defaultVertices[] =</span><br><span class="line">&#123;</span><br><span class="line">    &#123;&#123;-0.5f, -0.5f, 0.0f&#125;, &#123;0.0f, 0.0f&#125;&#125;,</span><br><span class="line">    &#123;&#123; 0.5f, -0.5f, 0.0f&#125;, &#123;1.0f, 0.0f&#125;&#125;,</span><br><span class="line">    &#123;&#123;-0.5f,  0.5f, 0.0f&#125;, &#123;0.0f, 1.0f&#125;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//move结构体 用于动画，各个坐标的变换动画效果</span><br><span class="line">static GLKVector3 movementVectors[3] = &#123;</span><br><span class="line">    &#123;-0.02f,  -0.01f, 0.0f&#125;,</span><br><span class="line">    &#123;0.01f,  -0.005f, 0.0f&#125;,</span><br><span class="line">    &#123;-0.01f,   0.01f, 0.0f&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface OpenGLES_3_2ViewController()&#123;</span><br><span class="line">     GLuint vertextBufferID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@property (nonatomic,strong)GLKBaseEffect *baseEffect;</span><br><span class="line">//是否使用线性过滤器</span><br><span class="line">@property (nonatomic,assign)BOOL shouldUseLineFilter;</span><br><span class="line">//是否开启动画</span><br><span class="line">@property (nonatomic,assign)BOOL shouldAnimate;</span><br><span class="line">//是否重复纹理</span><br><span class="line">@property (nonatomic,assign)BOOL shouldRepeatTexture;</span><br><span class="line">//顶点s坐标的offset</span><br><span class="line">@property (nonatomic,assign)GLfloat sCoordinateOffset;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>ViewDidload中初始化context和baseEffect以及load顶点缓存和纹理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">self.preferredFramesPerSecond = 60;</span><br><span class="line">self.shouldAnimate = YES;</span><br><span class="line">self.shouldRepeatTexture = YES;</span><br><span class="line">self.shouldUseLineFilter = NO;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GLKView *view = (GLKView *)self.view;</span><br><span class="line">NSAssert([view isKindOfClass:[GLKView class]], @&quot;View controller&apos;s is not a GLKView&quot;);</span><br><span class="line"></span><br><span class="line">view.context = [[EAGLContext alloc]initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br><span class="line">[EAGLContext setCurrentContext:view.context];</span><br><span class="line"></span><br><span class="line">self.baseEffect = [[GLKBaseEffect alloc]init];</span><br><span class="line">self.baseEffect.useConstantColor = GL_TRUE;</span><br><span class="line">self.baseEffect.constantColor = GLKVector4Make(1.0f, 1.0f, 1.0f, 1.0f);</span><br><span class="line">glClearColor(0.0f, 0.0f, 0.0f, 1.0f);</span><br><span class="line"></span><br><span class="line">//顶点缓存和纹理</span><br><span class="line">[self loadVertexBuffer];</span><br><span class="line">[self loadTexture];</span><br></pre></td></tr></table></figure>
<p>loadVertexBuffer和loadTexture</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)loadVertexBuffer&#123;</span><br><span class="line">    glGenBuffers(1, &amp;vertextBufferID);</span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, vertextBufferID);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_DYNAMIC_DRAW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)loadTexture&#123;</span><br><span class="line">    //绑定图片纹理</span><br><span class="line">    CGImageRef imageRef = [[UIImage imageNamed:@&quot;grid.png&quot;] CGImage];</span><br><span class="line">    GLKTextureInfo *textureInfo = [GLKTextureLoader textureWithCGImage:imageRef options:nil error:NULL];</span><br><span class="line">    self.baseEffect.texture2d0.name = textureInfo.name;</span><br><span class="line">    self.baseEffect.texture2d0.target = textureInfo.target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>绘制部分代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)glkView:(GLKView *)view drawInRect:(CGRect)rect&#123;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    [self.baseEffect prepareToDraw];</span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, vertextBufferID);</span><br><span class="line"></span><br><span class="line">    //设置vertex偏移指针</span><br><span class="line">    glEnableVertexAttribArray(GLKVertexAttribPosition);</span><br><span class="line">    glVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, sizeof(SceneVertex),NULL + offsetof(SceneVertex, positionCoords));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //设置textureCoords偏移指针</span><br><span class="line">    glEnableVertexAttribArray(GLKVertexAttribTexCoord0);</span><br><span class="line">    glVertexAttribPointer(GLKVertexAttribTexCoord0, 2, GL_FLOAT, GL_FALSE, sizeof(SceneVertex),NULL + offsetof(SceneVertex, textureCoord));</span><br><span class="line">    </span><br><span class="line">    //Draw</span><br><span class="line">    glDrawArrays(GL_TRIANGLES, 0, 3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心部分，我们在系统方法update里面更新顶点坐标和纹理取样设置参数，系统update方法调用频率和系统屏幕帧数一致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">- (void)update&#123;</span><br><span class="line">    </span><br><span class="line">    //更新动画顶点位置</span><br><span class="line">    [self updateAnimateVertexPositions];</span><br><span class="line"></span><br><span class="line">    //更新纹理参数设置</span><br><span class="line">    [self updateTextureParameters];</span><br><span class="line"></span><br><span class="line">    //刷新vertexBuffer</span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, vertextBufferID);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_DYNAMIC_DRAW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)updateTextureParameters&#123;</span><br><span class="line">    glBindTexture(self.baseEffect.texture2d0.target, self.baseEffect.texture2d0.name);</span><br><span class="line">    glTexParameterf(self.baseEffect.texture2d0.target, GL_TEXTURE_WRAP_S, (self.shouldRepeatTexture) ? GL_REPEAT : GL_CLAMP_TO_EDGE);</span><br><span class="line">    glTexParameterf(self.baseEffect.texture2d0.target, GL_TEXTURE_MAG_FILTER, (self.shouldUseLineFilter) ? GL_LINEAR : GL_NEAREST);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)updateAnimateVertexPositions&#123;</span><br><span class="line">    if (_shouldAnimate) &#123;</span><br><span class="line">        int I;</span><br><span class="line">        for (i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            vertices[i].positionCoords.x += movementVectors[i].x;</span><br><span class="line">            if (vertices[i].positionCoords.x &gt; 1.0f ||</span><br><span class="line">                vertices[i].positionCoords.x &lt; -1.0f) &#123;</span><br><span class="line">                movementVectors[i].x = -movementVectors[i].x;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            vertices[i].positionCoords.y += movementVectors[i].y;</span><br><span class="line">            if(vertices[i].positionCoords.y &gt;= 1.0f ||</span><br><span class="line">               vertices[i].positionCoords.y &lt;= -1.0f)</span><br><span class="line">            &#123;</span><br><span class="line">                movementVectors[i].y = -movementVectors[i].y;</span><br><span class="line">            &#125;</span><br><span class="line">            vertices[i].positionCoords.z += movementVectors[i].z;</span><br><span class="line">            if(vertices[i].positionCoords.z &gt;= 1.0f ||</span><br><span class="line">               vertices[i].positionCoords.z &lt;= -1.0f)</span><br><span class="line">            &#123;</span><br><span class="line">                movementVectors[i].z = -movementVectors[i].z;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        int I;</span><br><span class="line">        for(i = 0; i &lt; 3; I++)</span><br><span class="line">        &#123;</span><br><span class="line">            vertices[i].positionCoords.x =</span><br><span class="line">            defaultVertices[i].positionCoords.x;</span><br><span class="line">            vertices[i].positionCoords.y =</span><br><span class="line">            defaultVertices[i].positionCoords.y;</span><br><span class="line">            vertices[i].positionCoords.z =</span><br><span class="line">            defaultVertices[i].positionCoords.z;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#123;  // Adjust the S texture coordinates to slide texture and</span><br><span class="line">        // reveal effect of texture repeat vs. clamp behavior</span><br><span class="line">        int    i;  // &apos;i&apos; is current vertex index</span><br><span class="line">        for(i = 0; i &lt; 3; I++)</span><br><span class="line">        &#123;</span><br><span class="line">            vertices[i].textureCoord.s =</span><br><span class="line">            (defaultVertices[i].textureCoord.s +</span><br><span class="line">             _sCoordinateOffset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，我们更新完了数据源顶点的坐标需要重新glBufferData刷新GPU顶点缓存。</p>
</blockquote>
<p>以上呢我们就实现了一个基于OPENGL ES2.0的简单动画，并且呢直观演示了纹理取样的不同参数的实际效果。</p>
<h1 id="纹理混合"><a href="#纹理混合" class="headerlink" title="纹理混合"></a>纹理混合</h1><p>之前的Demo我们都是绘制了一张图片，如果是多个图片，也就是多个纹理的绘制如何处理呢。</p>
<p>OpenGL支持纹理混合，开启纹理混合非常的简单。<br>常用的混合调用以下函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//开启混合</span><br><span class="line">glEnable(GL_BLEND);</span><br><span class="line">glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br></pre></td></tr></table></figure>
<p>GL_ONE_MINUS_SRC_ALPHA该模式是让源片元的透明度元素和正在更新的像素的颜色元素相乘。<br>GL_SRC_ALPHA用于让源片元的透明度元素和其他的片元的透明度元素依次相乘。</p>
<p>那么帧缓存最终的像素颜色计算公式如下<br><img src="https://upload-images.jianshu.io/upload_images/1320629-c823616f09c82fa5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="帧缓存最终颜色计算公式"></p>
<p>好，我们就写一个Demo来做一下纹理混合</p>
<p>核心代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)fillTexture&#123;</span><br><span class="line">    //获取图片1</span><br><span class="line">    CGImageRef imageRef1 = [[UIImage imageNamed:@&quot;leaves.gif&quot;] CGImage];</span><br><span class="line">    //通过图片数据产生纹理缓存</span><br><span class="line">    NSDictionary* options = [NSDictionary dictionaryWithObjectsAndKeys:@(1), GLKTextureLoaderOriginBottomLeft, nil];</span><br><span class="line">    self.textureInfo1 = [GLKTextureLoader textureWithCGImage:imageRef1 options:options error:NULL];</span><br><span class="line">    </span><br><span class="line">    //获取图片2</span><br><span class="line">    CGImageRef imageRef2 = [[UIImage imageNamed:@&quot;beetle&quot;] CGImage];</span><br><span class="line">    self.textureInfo2 = [GLKTextureLoader textureWithCGImage:imageRef2 options:options error:NULL];</span><br><span class="line">    </span><br><span class="line">    //开启混合</span><br><span class="line">    glEnable(GL_BLEND);</span><br><span class="line">    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里开启GL_BLEND</p>
<p>绘制部分代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)glkView:(GLKView *)view drawInRect:(CGRect)rect&#123;</span><br><span class="line">    //清除背景色</span><br><span class="line">    glClearColor(0.0f,0.0f,0.0f,1.0f);</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line">    </span><br><span class="line">    //依次绘制顶点纹理1和纹理2</span><br><span class="line">    self.baseEffect.texture2d0.name = self.textureInfo1.name;</span><br><span class="line">    self.baseEffect.texture2d0.target = self.textureInfo1.target;</span><br><span class="line">    [self.baseEffect prepareToDraw];</span><br><span class="line">    glDrawArrays(GL_TRIANGLES, 0, 6);</span><br><span class="line">    </span><br><span class="line">    self.baseEffect.texture2d0.name = self.textureInfo2.name;</span><br><span class="line">    self.baseEffect.texture2d0.target = self.textureInfo2.target;</span><br><span class="line">    [self.baseEffect prepareToDraw];</span><br><span class="line">    glDrawArrays(GL_TRIANGLES, 0, 6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要依次绘制纹理1和纹理2，运行结果图如下<img src="https://upload-images.jianshu.io/upload_images/1320629-32a1c0e3c32587c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="纹理混合.png"></p>
<p>图2倍绘制在了图1的上方，这取决于纹理的绘制顺序。</p>
<p><strong>这种通过多次读写像素颜色渲染缓存叫做多通道渲染。<br>多通道渲染从性能上来看，每次更新界面图形都需要渲染多次，需要从帧缓存读取颜色数据和片元数据混合，再次写回帧缓存，显然多次的内存读取决定了混合在性能上是不佳的，是次优选择</strong></p>
<h1 id="多重纹理"><a href="#多重纹理" class="headerlink" title="多重纹理"></a>多重纹理</h1><p>目前CPU都支持同时从至少两个纹理缓存中取样纹素，也就是多重纹理，从而可以替代纹理混合，优化性能。</p>
<p>GLkit中GLKBaseEffect同时支持两个纹理。</p>
<p>核心代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)fillTexture&#123;</span><br><span class="line">    //获取图片1</span><br><span class="line">    CGImageRef imageRef1 = [[UIImage imageNamed:@&quot;leaves.gif&quot;] CGImage];</span><br><span class="line">    //通过图片数据产生纹理缓存</span><br><span class="line">    NSDictionary* options = [NSDictionary dictionaryWithObjectsAndKeys:@(1), GLKTextureLoaderOriginBottomLeft, nil];</span><br><span class="line">    self.textureInfo1 = [GLKTextureLoader textureWithCGImage:imageRef1 options:options error:NULL];</span><br><span class="line">    </span><br><span class="line">    //获取图片2</span><br><span class="line">    CGImageRef imageRef2 = [[UIImage imageNamed:@&quot;beetle&quot;] CGImage];</span><br><span class="line">    self.textureInfo2 = [GLKTextureLoader textureWithCGImage:imageRef2 options:options error:NULL];</span><br><span class="line">    </span><br><span class="line">    self.baseEffect.texture2d0.name = self.textureInfo1.name;</span><br><span class="line">    self.baseEffect.texture2d0.target = self.textureInfo1.target;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    self.baseEffect.texture2d1.name = self.textureInfo2.name;</span><br><span class="line">    self.baseEffect.texture2d1.target = self.textureInfo2.target;</span><br><span class="line">    //设置混合EnvMode</span><br><span class="line">    self.baseEffect.texture2d1.envMode = GLKTextureEnvModeDecal;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里创建了两个纹理缓存并且设置了纹理2的envMode为GLKTextureEnvModeDecal，GLKTextureEnvModeDecal是和glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);效果一样的。计算公式一致</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)fillVertexArray&#123;</span><br><span class="line">    glGenBuffers(1, &amp;vertextBufferID);</span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, vertextBufferID); //绑定指定标识符的缓存为当前缓存</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    glEnableVertexAttribArray(GLKVertexAttribPosition); //顶点数据缓存</span><br><span class="line">    glVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, sizeof(SceneVertex), NULL + offsetof(SceneVertex, positionCoords));</span><br><span class="line">    </span><br><span class="line">    glEnableVertexAttribArray(GLKVertexAttribTexCoord0); //纹理0</span><br><span class="line">    glVertexAttribPointer(GLKVertexAttribTexCoord0, 2, GL_FLOAT, GL_FALSE, sizeof(SceneVertex), NULL + offsetof(SceneVertex, textureCoords));</span><br><span class="line">    </span><br><span class="line">    glEnableVertexAttribArray(GLKVertexAttribTexCoord1); //纹理1</span><br><span class="line">    glVertexAttribPointer(GLKVertexAttribTexCoord1, 2, GL_FLOAT, GL_FALSE, sizeof(SceneVertex), NULL + offsetof(SceneVertex, textureCoords));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里设置顶点纹理数据指针偏移时候开启了GLKVertexAttribTexCoord0 和GLKVertexAttribTexCoord1两个纹理</p>
<p>绘制部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)glkView:(GLKView *)view drawInRect:(CGRect)rect&#123;</span><br><span class="line">    //清除背景色</span><br><span class="line">    glClearColor(0.0f,0.0f,0.0f,1.0f);</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line">    [self.baseEffect prepareToDraw];</span><br><span class="line">    glDrawArrays(GL_TRIANGLES, 0, 6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里多重纹理就避免了重复和多次绘制，性能比纹理混合要好，是绘制多个纹理时候的优先选择。</p>
<p>Demo代码地址：<a href="https://github.com/AceDong0803/LearnOpenGLESDemo/tree/master" target="_blank" rel="noopener">LearnOpenGLESDemo</a></p>
<p>源码来源于书籍：1. <a href="https://book.douban.com/subject/24849591/" target="_blank" rel="noopener">OpenGL ES应用开发实践指南：iOS卷</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/25/iOS-OpenGL-ES入门教程（二）最简单的纹理Demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ace Dong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安东的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/25/iOS-OpenGL-ES入门教程（二）最简单的纹理Demo/" itemprop="url">iOS-OpenGL-ES入门教程（二）最简单的纹理Demo</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-25T22:08:05+08:00">
                2018-04-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇介绍了绘制OpenGL ES的Hello world也就是一个三角形。现在我们介绍下OpenGL ES的一个另一个基础，纹理，并且编写一个最简单的demo绘制一张图片。</p>
<h1 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h1><p>初学呢，我们可以把纹理理解为一张图片，我们可以将整张图片绘制到圆形，矩形等目标图形中，既可以绘制部分图，也可以重复使用图片绘制，也就是纹理了哈。</p>
<h1 id="矩形图"><a href="#矩形图" class="headerlink" title="矩形图"></a>矩形图</h1><p>我们目标是绘制一个矩形图，在OpenGL ES中任何复杂的图形都是由点，线和三角形组成的哈。很简单，一个矩形就是两个三角形组成。嚯嚯。So easy。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1320629-5ac305e857ecc473.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="矩形"></p>
<p>好滴，那么矩形的六个顶点有了哈</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const GLfloat vertices[] = &#123;</span><br><span class="line">        1, -1, 0.0f,   //D</span><br><span class="line">        1, 1,  0.0f,   //B</span><br><span class="line">        -1, 1, 0.0f,   //A</span><br><span class="line">        </span><br><span class="line">        1, -1, 0.0f,   //D</span><br><span class="line">        -1, 1, 0.0f,   //A</span><br><span class="line">        -1, -1, 0.0f,   //C </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>很明显我们的顶点是需要和纹理坐标一一对应的，如下图，<br><img src="https://upload-images.jianshu.io/upload_images/1320629-ec31fbf74522a77e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="顶点和纹理映射图"></p>
<blockquote>
<p>需要注意的是：纹理坐标系是左下角为坐标系顶点，而顶点坐标系屏幕中心为顶点</p>
</blockquote>
<p>好滴，那么我们的数据源就有了哈。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//顶点数据</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    GLKVector3 positionCoords; </span><br><span class="line">    GLKVector2 textureCoords;//纹理</span><br><span class="line">&#125;SceneVertex;</span><br><span class="line"></span><br><span class="line">//矩形的六个顶点</span><br><span class="line">static const SceneVertex vertices[] = &#123;</span><br><span class="line">    &#123;&#123;1, -1, 0.0f,&#125;,&#123;1.0f,0.0f&#125;&#125;, //右下</span><br><span class="line">    &#123;&#123;1, 1,  0.0f&#125;,&#123;1.0f,1.0f&#125;&#125;, //右上</span><br><span class="line">    &#123;&#123;-1, 1, 0.0f&#125;,&#123;0.0f,1.0f&#125;&#125;, //左上</span><br><span class="line">    </span><br><span class="line">    &#123;&#123;1, -1, 0.0f&#125;,&#123;1.0f,0.0f&#125;&#125;, //右下</span><br><span class="line">    &#123;&#123;-1, 1, 0.0f&#125;,&#123;0.0f,1.0f&#125;&#125;, //左上</span><br><span class="line">    &#123;&#123;-1, -1, 0.0f&#125;,&#123;0.0f,0.0f&#125;&#125;, //左下</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>textureCoords即是纹理位置。</p>
<h1 id="设置OpenGLES上下文"><a href="#设置OpenGLES上下文" class="headerlink" title="设置OpenGLES上下文"></a>设置OpenGLES上下文</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//新建OpenGLES 上下文</span><br><span class="line">    GLKView *view = (GLKView *)self.view;</span><br><span class="line">    view.context = [[EAGLContext alloc]initWithAPI: kEAGLRenderingAPIOpenGLES2];</span><br><span class="line">    //设置当前上下文</span><br><span class="line">    [EAGLContext setCurrentContext:view.context];</span><br><span class="line">    </span><br><span class="line">    self.baseEffect = [[GLKBaseEffect alloc]init];</span><br><span class="line">    self.baseEffect.useConstantColor = GL_TRUE;</span><br><span class="line">    self.baseEffect.constantColor = GLKVector4Make(1.0f, 1.0f, 1.0f, 1.0f);</span><br></pre></td></tr></table></figure>
<p>这是第一步。</p>
<h1 id="设置顶点缓存buffer"><a href="#设置顶点缓存buffer" class="headerlink" title="设置顶点缓存buffer"></a>设置顶点缓存buffer</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)fillVertexArray&#123;</span><br><span class="line">    glGenBuffers(1, &amp;vertextBufferID);</span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, vertextBufferID); //绑定指定标识符的缓存为当前缓存</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    glEnableVertexAttribArray(GLKVertexAttribPosition); //顶点数据缓存</span><br><span class="line">    glVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, sizeof(SceneVertex), NULL + offsetof(SceneVertex, positionCoords));</span><br><span class="line">    glEnableVertexAttribArray(GLKVertexAttribTexCoord0); //纹理</span><br><span class="line">    glVertexAttribPointer(GLKVertexAttribTexCoord0, 2, GL_FLOAT, GL_FALSE, sizeof(SceneVertex), NULL + offsetof(SceneVertex, textureCoords));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们生成绑定了顶点和纹理buffer，并且设置了对应的指针偏移量。</p>
<h1 id="生成纹理"><a href="#生成纹理" class="headerlink" title="生成纹理"></a>生成纹理</h1><p>这里我们使用GLkit中的GLKTextureInfo方便的生成图片纹理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//获取图片</span><br><span class="line"> CGImageRef imageRef = [[UIImage imageNamed:@&quot;Demo.jpg&quot;] CGImage];</span><br><span class="line"> </span><br><span class="line"> //通过图片数据产生纹理缓存</span><br><span class="line"> //GLKTextureInfo封装了纹理缓存的信息，包括是否包含MIP贴图</span><br><span class="line"> GLKTextureInfo *textureInfo = [GLKTextureLoader textureWithCGImage:imageRef options:nil error:NULL];</span><br><span class="line"> self.baseEffect.texture2d0.name = textureInfo.name;</span><br><span class="line"> self.baseEffect.texture2d0.target = textureInfo.target;</span><br></pre></td></tr></table></figure>
<p>GLKBaseEffect让我们避开了写shader Language。</p>
<h1 id="绘制-amp-释放"><a href="#绘制-amp-释放" class="headerlink" title="绘制 &amp; 释放"></a>绘制 &amp; 释放</h1><p>最后一步就是绘制了，这步非常简单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)glkView:(GLKView *)view drawInRect:(CGRect)rect&#123;</span><br><span class="line">    //清除背景色</span><br><span class="line">    glClearColor(0.0f,0.0f,0.0f,1.0f);</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line">    [self.baseEffect prepareToDraw];</span><br><span class="line">    glDrawArrays(GL_TRIANGLES, 0, 6);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">    GLKView *view = (GLKView *)self.view;</span><br><span class="line">    [EAGLContext setCurrentContext:view.context];</span><br><span class="line">    if ( 0 != vertextBufferID) &#123;</span><br><span class="line">        glDeleteBuffers(1,</span><br><span class="line">                        &amp;vertextBufferID);</span><br><span class="line">        vertextBufferID = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    [EAGLContext setCurrentContext:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小思考：因为这次绘制的是静态图，所以我们直接在viewdidload里面就生成绑定好了顶点数据缓存，而不是在drawInRect方法中。如果要做一些动态变化，就需要在drawInRect方法中动态刷新缓存数据</p>
</blockquote>
<p>看下最后运行结果</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1320629-0f0521d81c0e8370.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果-彭于晏"></p>
<p>图片正常显示了，但是倒立了，这个是因为CoreGraphics的坐标系问题。我们生成纹理的时候option加个坐标系变换就OK了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary* options = [NSDictionary dictionaryWithObjectsAndKeys:@(1), GLKTextureLoaderOriginBottomLeft, nil];</span><br><span class="line">   GLKTextureInfo *textureInfo = [GLKTextureLoader textureWithCGImage:imageRef options:options error:NULL];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小思考: 我们这里实现了最简单的纹理图片绘制，但是由于图标本身的尺寸被全屏展示后出现了拉伸，怎么保证图片按比例的绘制在屏幕中呢？</p>
</blockquote>
<p>Demo代码地址：<a href="https://github.com/AceDong0803/LearnOpenGLESDemo/tree/master" target="_blank" rel="noopener">LearnOpenGLESDemo</a></p>
<p>参考书籍：1. <a href="https://book.douban.com/subject/24849591/" target="_blank" rel="noopener">OpenGL ES应用开发实践指南：iOS卷</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/27/iOS实时录音编码保存Mp3-Demo-使用Lame实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ace Dong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安东的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/27/iOS实时录音编码保存Mp3-Demo-使用Lame实现/" itemprop="url">iOS实时录音编码保存Mp3-使用Lame实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-27T20:08:05+08:00">
                2018-03-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Lame开源库"><a href="#Lame开源库" class="headerlink" title="Lame开源库"></a>Lame开源库</h1><p>Lame是一款优秀的mp3开源跨平台编码库，可以将音频裸PCM数据编码成mp3。<br>先去官方下载Lame源代码: <a href="http://lame.sourceforge.net" target="_blank" rel="noopener">Lame下载地址</a><br>然后编译静态库，这里呢不再累述，可以自己写编译脚本，也可以去Github上下载编译脚本。脚本下载链接: <a href="https://github.com/kewlbear/lame-ios-build" target="_blank" rel="noopener">lame-build-script</a></p>
<p>这里呢我已经编译好了Lame静态库，包含了x86，arm64架构，需要的童鞋可以直接下载，Lame版本是最新的V3.100。网盘下载地址: <a href="https://pan.baidu.com/s/1aSna386D8RXY9aGhfoHUfQ" target="_blank" rel="noopener">iOSLame静态库</a></p>
<h1 id="PCM"><a href="#PCM" class="headerlink" title="PCM"></a>PCM</h1><p>PCM(Pulse Code Modulation)：脉码编码调制。是没有压缩的音频数据，也可以叫音频裸数据。我们经常可以看到音频参数中有44100HZ 16bit，或者是22050HZ 8bit。<br>这里呢其实是两个参数<br>采样率：自然界的音频即声波转换为数字数据保存，即模-》数，单位时间采样个数即采样率。很明显，采样率越高，精确度越大。人对频率的识别范围是 20HZ - 20000HZ。所以22050的采样频率是常用的音频采样率，而44100采样率即是CD级别。</p>
<p>16bit pcm意味着使用两个字节去保存采样值。<br> 采样数据记录的是振幅, 采样精度取决于储存空间的大小:<br> 1 字节(也就是8bit) 256, 也就是只能将振幅划分成 256 个等级;<br> 2 字节(也就是16bit) 65536个等级 , CD级别，16bit pcm就是最常见的。<br> 4 字节(也就是32bit) 能把振幅细分到 4294967296 个等级, 一般不常用。</p>
<p>双声道<br>裸数据的音频存在双声道，即左右耳，我们看下PCM双声道的存储结构。<img src="https://upload-images.jianshu.io/upload_images/1320629-2cdc6c84b50fc9e0.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PCM存储结构"></p>
<p>我们可与看到16bit的PCM和8Bit的PCM双声道都是左右声道交替存储的，所不同的是，16位是每两个字节存储一个声道数据，而8位是一个字节，然后再交替存储。</p>
<blockquote>
<p>这里了解下PCM存储结构是为了后面我们从文件流取出对应声道数据。</p>
</blockquote>
<h1 id="本地PCM文件转码为Mp3文件"><a href="#本地PCM文件转码为Mp3文件" class="headerlink" title="本地PCM文件转码为Mp3文件"></a>本地PCM文件转码为Mp3文件</h1><p>本地PCM文件，我在上面的网盘保存了一份，需要的可以下载，也可以自己通过FFMpeg指令生成PCM裸数据，以MP3转PCM为例</p>
<blockquote>
<p>ffmpeg -i test.mp3 -f s16le -ar 8000 test.pcm</p>
</blockquote>
<p>实际项目中音视频相关的底层接口通常是跨平台设计的，为了兼容iOS/Android/Windows/Linux等，通常底层接口使用C++编写封装。</p>
<p>这里我们写一个简单的C++类 Mp3Encoder</p>
<blockquote>
<p>使用Objective-C也是同样的接口调用，在Demo中也存放了一个OC封装类，需要的可以下载查看。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Mp3Encoder &#123;</span><br><span class="line">    private:</span><br><span class="line">    FILE* pcmFile;</span><br><span class="line">    FILE* mp3File;</span><br><span class="line">    lame_t lameClient;</span><br><span class="line">    </span><br><span class="line">    public:</span><br><span class="line">    </span><br><span class="line">    Mp3Encoder();</span><br><span class="line">    ~Mp3Encoder();</span><br><span class="line">    /**</span><br><span class="line">     pcm编码成Mp3文件</span><br><span class="line">     @param pcmFilePath pcm源文件路径</span><br><span class="line">     @param mp3FilePath 编码完成mp3文件路径</span><br><span class="line">     @param sampleRate 采样率</span><br><span class="line">     @param channels 通道数</span><br><span class="line">     @param bitRate 码率</span><br><span class="line">     */</span><br><span class="line">    //每个任务都需要初始化一次</span><br><span class="line">    int Init(const char* pcmFilePath,const char *mp3FilePath,int sampleRate,int channels,int bitRate);</span><br><span class="line">    </span><br><span class="line">    //编码本地文件</span><br><span class="line">    void EncodeLocalFile();</span><br><span class="line">    </span><br><span class="line">    //销毁资源</span><br><span class="line">    void Destroy();</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>初始化Mp3Encoder类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int Mp3Encoder::Init(const char *pcmFilePath, const char *mp3FilePath, int sampleRate, int channels, int bitRate)&#123;</span><br><span class="line">    encodeEnd = false;</span><br><span class="line">    int ret = -1;</span><br><span class="line">    //只读文件流，读取原PCM数据路径</span><br><span class="line">    pcmFile = fopen(pcmFilePath, &quot;rb&quot;);</span><br><span class="line">    if(pcmFile)&#123;</span><br><span class="line">         //读写文件流，目标Mp3写入生成路径</span><br><span class="line">        mp3File = fopen(mp3FilePath, &quot;wb+&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(mp3File)&#123;</span><br><span class="line">        //初始化Lame</span><br><span class="line">        lameClient = lame_init();</span><br><span class="line">        lame_set_in_samplerate(lameClient,sampleRate); //设置输入采样率</span><br><span class="line">        lame_set_out_samplerate(lameClient, sampleRate); //设置输出采样率</span><br><span class="line">        lame_set_num_channels(lameClient, channels); //设置声道数</span><br><span class="line">        lame_set_brate(lameClient, bitRate); //设置码率</span><br><span class="line">        lame_set_quality(lameClient,2);  //设置转码质量高</span><br><span class="line">        lame_init_params(lameClient);   //完成设置</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转码Mp3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void Mp3Encoder::EncodeLocalFile()&#123;</span><br><span class="line">    //跳过 PCM header 否者会有一些噪音在MP3开始播放处</span><br><span class="line">    fseek(pcmFile, 4*1024,  SEEK_CUR);</span><br><span class="line">    int bufferSize = 256 * 1024;</span><br><span class="line">    short *buffer = new short[bufferSize/2];</span><br><span class="line">    short *leftBuffer = new short[bufferSize/4];</span><br><span class="line">    short *rightBuffer = new short[bufferSize/4];</span><br><span class="line">    unsigned char* mp3_buffer = new unsigned char[bufferSize];</span><br><span class="line">    size_t readBufferSize = 0;</span><br><span class="line">    //双声道获取比特率的数据</span><br><span class="line">    while ((readBufferSize = fread(buffer, 2, bufferSize/2, pcmFile))&gt;0) &#123;</span><br><span class="line">        for(int i = 0;i &lt; readBufferSize;i++)&#123;</span><br><span class="line">            if(i % 2 == 0)&#123;</span><br><span class="line">                leftBuffer[i/2] = buffer[I];</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                rightBuffer[i/2] = buffer[I];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        size_t wroteSize = lame_encode_buffer(lameClient, (short int *)leftBuffer, (short int *)rightBuffer, (int)(readBufferSize / 2), mp3_buffer, bufferSize);</span><br><span class="line">        fwrite(mp3_buffer, 1, wroteSize, mp3File);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //写入Mp3 VBR Tag，不是必须的步骤</span><br><span class="line">    lame_mp3_tags_fid(lameClient, mp3File);</span><br><span class="line">    delete []buffer;</span><br><span class="line">    delete []leftBuffer;</span><br><span class="line">    delete []rightBuffer;</span><br><span class="line">    delete []mp3_buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转码Mp3这里有几点注意事项</p>
<ol>
<li>PCM数据头有四个字节的头信息，这里我们跳过，避免编码产生头噪音</li>
<li>我们设置了一个Buffer 为256 *1024大小，从文件流每次读取一定数量buffer转码MP3写入，直到全部读取完文件流</li>
<li>需要特别注意的是下面我们从文件流每次读取两个字节的数据，依次存入buffer，这里由于demo处理的是16位PCM数据，所以左右声道各占两个字节，如果是8bit或者32bit则需要分别读取1个字节和4个字节数据。这样才能分离出左右声道数据<br><code>readBufferSize = fread(buffer, 2, bufferSize/2, pcmFile)</code></li>
<li>编码Mp3区分左右声道<br><code>lame_encode_buffer(lameClient, (short int *)leftBuffer, (short int *)rightBuffer, (int)(readBufferSize / 2), mp3_buffer, bufferSize)</code></li>
<li>编码完成之后，写入Mp3的VBR tag,如果不写入的话，可能会导致某些播放器播放时获取时长出现问题，所以建议写入。（VBR Tag这里不再介绍，需要了解的可以自行查阅Mp3封装格式哈）<br><code>//写入Mp3 VBR Tag，不是必须的步骤
 lame_mp3_tags_fid(lameClient, mp3File);</code></li>
</ol>
<p>最后外部调用编码接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">     //异步转换本地PCM文件</span><br><span class="line">    dispatch_async(localMp3EncodeQueue(), ^&#123;</span><br><span class="line">        [self testLocalPCMToMp3];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">- (void)testLocalPCMToMp3&#123;</span><br><span class="line">    //获取原PCM路径 需要PCM，自己放一段，或者在我的blog网盘上面获取下载Demo PCM</span><br><span class="line">    NSString *pcmPath = [[NSBundle mainBundle] pathForResource:@&quot;test&quot; ofType:@&quot;pcm&quot;];</span><br><span class="line">    </span><br><span class="line">    //输出目标MP3路径</span><br><span class="line">    NSString *mp3Path = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:[NSString stringWithFormat:@&quot;%@/LoacalTest.mp3&quot;,MP3SaveFilePath]];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%@&quot;,mp3Path);</span><br><span class="line">    </span><br><span class="line">    //编码Mp3  sampleRate使用标准Mp3 44.1khz 双声道 码率使用128kb</span><br><span class="line">    Mp3Encoder encode;</span><br><span class="line">    encode.Init([pcmPath cStringUsingEncoding:NSUTF8StringEncoding], [mp3Path cStringUsingEncoding:NSUTF8StringEncoding], 44100, 2, 128);</span><br><span class="line">    </span><br><span class="line">    //开始编码</span><br><span class="line">    encode.EncodeLocalFile();</span><br><span class="line">    </span><br><span class="line">    //释放资源</span><br><span class="line">    encode.Destroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>至此我们就实现了简单的PCM文件本地编码成Mp3文件</p>
</blockquote>
<h1 id="实时录音编码Mp3实现"><a href="#实时录音编码Mp3实现" class="headerlink" title="实时录音编码Mp3实现"></a>实时录音编码Mp3实现</h1><p>其实实时录音实现流程如下<br><img src="https://upload-images.jianshu.io/upload_images/1320629-7d53231eb3d41f0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实时录音编码Mp3保存流程图"></p>
<p>其实和本地编码保存不同的是，我们需要循环读取源文件的PCM数据，直到录音结束，停止循环，保存最终mp3,核心代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">class Mp3Encoder &#123;</span><br><span class="line">    private:</span><br><span class="line">    FILE* pcmFile;</span><br><span class="line">    FILE* mp3File;</span><br><span class="line">    lame_t lameClient;</span><br><span class="line">    </span><br><span class="line">    public:</span><br><span class="line">    </span><br><span class="line">    //标志位，用于编录音编解码的录音结束标识符</span><br><span class="line">    bool encodeEnd;</span><br><span class="line">    </span><br><span class="line">    Mp3Encoder();</span><br><span class="line">    ~Mp3Encoder();</span><br><span class="line">    /**</span><br><span class="line">     pcm编码成Mp3文件</span><br><span class="line">     @param pcmFilePath pcm源文件路径</span><br><span class="line">     @param mp3FilePath 编码完成mp3文件路径</span><br><span class="line">     @param sampleRate 采样率</span><br><span class="line">     @param channels 通道数</span><br><span class="line">     @param bitRate 码率</span><br><span class="line">     */</span><br><span class="line">    //每个任务都需要初始化一次</span><br><span class="line">    int Init(const char* pcmFilePath,const char *mp3FilePath,int sampleRate,int channels,int bitRate);</span><br><span class="line">    </span><br><span class="line">    //编码本地文件</span><br><span class="line">    void EncodeLocalFile();</span><br><span class="line">    </span><br><span class="line">    //边录制边解码</span><br><span class="line">    void EncodeStreamFile();</span><br><span class="line">    </span><br><span class="line">    //销毁资源</span><br><span class="line">    void Destroy();</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int Mp3Encoder::Init(const char *pcmFilePath, const char *mp3FilePath, int sampleRate, int channels, int bitRate)&#123;</span><br><span class="line">    encodeEnd = false;</span><br><span class="line">    int ret = -1;</span><br><span class="line">    //只读文件流，读取原PCM数据路径</span><br><span class="line">    pcmFile = fopen(pcmFilePath, &quot;rb&quot;);</span><br><span class="line">    if(pcmFile)&#123;</span><br><span class="line">         //读写文件流，目标Mp3写入生成路径</span><br><span class="line">        mp3File = fopen(mp3FilePath, &quot;wb+&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(mp3File)&#123;</span><br><span class="line">        //初始化Lame</span><br><span class="line">        lameClient = lame_init();</span><br><span class="line">        lame_set_in_samplerate(lameClient,sampleRate); //设置输入采样率</span><br><span class="line">        lame_set_out_samplerate(lameClient, sampleRate); //设置输出采样率</span><br><span class="line">        lame_set_num_channels(lameClient, channels); //设置声道数</span><br><span class="line">        lame_set_brate(lameClient, bitRate); //设置码率</span><br><span class="line">        lame_set_quality(lameClient,2);  //设置转码质量高</span><br><span class="line">        lame_init_params(lameClient);   //完成设置</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Mp3Encoder::EncodeStreamFile()&#123;</span><br><span class="line">    </span><br><span class="line">    //双声道获取比特率的数据</span><br><span class="line">    int bufferSize = 256 * 1024;</span><br><span class="line">    short *buffer = new short[bufferSize/2];</span><br><span class="line">    short *leftBuffer = new short[bufferSize/4];</span><br><span class="line">    short *rightBuffer = new short[bufferSize/4];</span><br><span class="line">    unsigned char* mp3_buffer = new unsigned char[bufferSize];</span><br><span class="line">    size_t readBufferSize = 0;</span><br><span class="line">    </span><br><span class="line">    bool isSkipPcmHeader = false;</span><br><span class="line">    long curPos;</span><br><span class="line">    </span><br><span class="line">    //循环读取数据编码</span><br><span class="line">    do &#123;</span><br><span class="line">            curPos = ftell(pcmFile);</span><br><span class="line">            long startPos = ftell(pcmFile);</span><br><span class="line">            fseek(pcmFile, 0, SEEK_END);</span><br><span class="line">            long endPos = ftell(pcmFile);</span><br><span class="line">            long totalDataLength = endPos - startPos;</span><br><span class="line">            fseek(pcmFile, curPos, SEEK_SET);</span><br><span class="line">            if (totalDataLength &gt; bufferSize) &#123;</span><br><span class="line">                if (!isSkipPcmHeader) &#123;</span><br><span class="line">                    //跳过 PCM header 否者会有一些噪音在MP3开始播放处</span><br><span class="line">                    fseek(pcmFile, 4*1024,  SEEK_CUR);</span><br><span class="line">                    isSkipPcmHeader = true;</span><br><span class="line">                &#125;</span><br><span class="line">                readBufferSize = fread(buffer, 2, bufferSize/2, pcmFile);</span><br><span class="line">                //双声道的处理</span><br><span class="line">                for(int i = 0;i &lt; readBufferSize;i++)&#123;</span><br><span class="line">                    if(i % 2 == 0)&#123;</span><br><span class="line">                        leftBuffer[i/2] = buffer[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                    else&#123;</span><br><span class="line">                        rightBuffer[i/2] = buffer[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                size_t wroteSize = lame_encode_buffer(lameClient, (short int *)leftBuffer, (short int *)rightBuffer, (int)(readBufferSize / 2), mp3_buffer, bufferSize);</span><br><span class="line">                fwrite(mp3_buffer, 1, wroteSize, mp3File);</span><br><span class="line">            &#125;</span><br><span class="line">        //sleep 0.05s</span><br><span class="line">        sleep(0.05);</span><br><span class="line">        </span><br><span class="line">    &#125; while (!encodeEnd);</span><br><span class="line">    </span><br><span class="line">    //这里需要注意的是，一旦录音结束encodeEnd就会导致上面的函数结束，有可能出现解码慢，导致录音结束，仍然没有解码完所有数据的可能</span><br><span class="line">    //循环读取剩余数据进行编码</span><br><span class="line">    while ((readBufferSize = fread(buffer, 2, bufferSize/2, pcmFile))&gt;0) &#123;</span><br><span class="line">        for(int i = 0;i &lt; readBufferSize;i++)&#123;</span><br><span class="line">            if(i % 2 == 0)&#123;</span><br><span class="line">                leftBuffer[i/2] = buffer[i];</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                rightBuffer[i/2] = buffer[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        size_t wroteSize = lame_encode_buffer(lameClient, (short int *)leftBuffer, (short int *)rightBuffer, (int)(readBufferSize / 2), mp3_buffer, bufferSize);</span><br><span class="line">        fwrite(mp3_buffer, 1, wroteSize, mp3File);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //写入Mp3 VBR Tag，不是必须的步骤</span><br><span class="line">    lame_mp3_tags_fid(lameClient, mp3File);</span><br><span class="line">    delete []buffer;</span><br><span class="line">    delete []leftBuffer;</span><br><span class="line">    delete []rightBuffer;</span><br><span class="line">    delete []mp3_buffer;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用AVAudioRecord录制音频<br>录音核心参数如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  录音参数设置</span><br><span class="line"> */</span><br><span class="line">- (NSDictionary *)getAudioSetting&#123;</span><br><span class="line">    NSMutableDictionary *dicM = [NSMutableDictionary dictionary];</span><br><span class="line">    [dicM setObject:@(kAudioFormatLinearPCM) forKey:AVFormatIDKey];</span><br><span class="line">    [dicM setObject:@(sampleRate) forKey:AVSampleRateKey]; //44.1khz的采样率</span><br><span class="line">    [dicM setObject:@(2) forKey:AVNumberOfChannelsKey];</span><br><span class="line">    [dicM setObject:@(16) forKey:AVLinearPCMBitDepthKey]; //16bit的PCM数据</span><br><span class="line">    [dicM setObject:[NSNumber numberWithInt:AVAudioQualityMax] forKey:AVEncoderAudioQualityKey];</span><br><span class="line">    return dicM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><p> 项目源代码github地址：<a href="https://github.com/AceDong0803/iOS-Record-Transcoding-mp3-lameDemo" target="_blank" rel="noopener">iOS-Record-Transcoding-mp3-lameDemo</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/27/iOS-零基础学习OpenGL-ES入门教程（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ace Dong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安东的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/27/iOS-零基础学习OpenGL-ES入门教程（一）/" itemprop="url">iOS-OpenGL-ES入门教程（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-27T21:08:05+08:00">
                2018-02-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>因为做的摄像头相关工作，工作中常用到OpenGL去做视频渲染，图形变换等，虽说满足了开发需求，但是自己对于OpenGL的学习一直没有很系统完善，属于需求驱动学习。所以才有了这个开篇</p>
<blockquote>
<p>OpenGL ES的开始学习必然是有一点点枯燥和难理解的哈，没有C语言编程基础的童鞋，初次接触C接口编程会有一点疑惑，但是没关系，所谓孰能生巧，多思考，练习即可。</p>
</blockquote>
<p>学习书籍这块：</p>
<ol>
<li><a href="https://book.douban.com/subject/24849591/" target="_blank" rel="noopener">OpenGL ES应用开发实践指南：iOS卷</a></li>
<li>红宝书 <a href="https://book.douban.com/subject/4311129/" target="_blank" rel="noopener">OpenGL Programming Guide</a>，出到第八版</li>
<li>蓝宝书 <a href="https://book.douban.com/subject/5332844/" target="_blank" rel="noopener">OpenGL SuperBible</a>，出到第六版</li>
</ol>
<p>入门教程以及demo代码主要来源于《OpenGL ES应用开发实践指南：iOS卷》</p>
<h1 id="OpenGL-ES概述"><a href="#OpenGL-ES概述" class="headerlink" title="OpenGL ES概述"></a>OpenGL ES概述</h1><p>关于概念介绍我就贴上百度了哈（哈哈，偷懒一下）<br><a href="https://baike.baidu.com/item/OpenGL%20ES/7922580?fr=aladdin" target="_blank" rel="noopener">OpenGL ES百度百科</a></p>
<p>OK，OpenGL是用于2D/3D图形编程的一套基于C语言的统一接口，在桌面windows，Mac，Linux/Unix上均可兼容。</p>
<p>OpenGL ES是在OpenGL嵌入式设备上面的版本，也就是安卓/iPhone，其他嵌入式等移动设备的编程规范。（除此之外，在web上也有相应的WebGL）</p>
<p>现在在iOS平台上目前支持的OpenGL版本有</p>
<ul>
<li>OpenGL1.0</li>
<li>OpenGL2.0</li>
<li>OpenGL3.0</li>
</ul>
<p>后面的教程均基于OpenGL2.0环境下。（其中1.0版本基本已经不再使用了。）</p>
<p>从上面的简单介绍我们知道了OpenGL ES是做图形编程的，<br>下图摘自苹果的官方介绍:  <a href="https://developer.apple.com/library/content/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html" target="_blank" rel="noopener">OpenGL ES Programming Guide</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1320629-10c1d4466b71a2c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cpu_gpu_2x.png"></p>
<p>可以看到我们通过OpenGL ES驱动gpu图形处理器实现图形编程。</p>
<blockquote>
<p>发散小思考: OpenGL ES作为iOS相对底层库，可以完成2D/3D图形渲染，那么我们平常的UIView也可以基于CoreAnimation完成3D动画，图形显示，那么UIView和OpenGL有什么内在关系呢，我们的iPhone最终是怎么完成图像显示的呢？</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1320629-2ec543db167198c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Cocoa Touch OpenGL ES软件架构"></p>
<p>从上图可以看到core animation Layers就是通过OpenGL ES绘制最后混合，然后通过帧缓存显示到屏幕上的。</p>
<h1 id="iOS-OpenGL-ES最简单的实践"><a href="#iOS-OpenGL-ES最简单的实践" class="headerlink" title="iOS OpenGL ES最简单的实践"></a>iOS OpenGL ES最简单的实践</h1><p>OK，由于是开篇，下面我们通过一个简单的例子完成一个三角形的绘制<br>在这里我们使用GLkit：这是苹果做的一层封装，可以简化在iOS下OPENGL ES代码。</p>
<blockquote>
<p>至于GLkit具体做了什么，后面随着我们深入学习可以再回头来看，后面会编写不使用GLkit的demo，可以通过比对来看到底优化了哪些流程，这里暂时只需要记住使用GLkit可以简化代码。</p>
</blockquote>
<ul>
<li>GLKViewController：UIViewController的子类，接收当视图需要重绘时的消息</li>
<li>GLKView：UIView的子类，简化了通过用Core Animation层来自动创建并管理帧缓存和渲染缓存共享内存所需要做的工作。</li>
</ul>
<ol>
<li>创建OpenGL ES上下文<br>创建一个GLKViewController，在ViewdidLoad生命周期中：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GLKView *view  = (GLKView *)self.view;</span><br><span class="line">//创建OpenGL ES2.0上下文</span><br><span class="line">view.context = [[EAGLContext alloc]initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br><span class="line">//设置当前上下文</span><br><span class="line">[EAGLContext setCurrentContext:view.context];</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>声明一个GLKBaseEffect属性</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic,strong)GLKBaseEffect *baseEffect;</span><br></pre></td></tr></table></figure>
<p>并且在ViewDidLoad实例化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  self.baseEffect = [[GLKBaseEffect alloc]init];</span><br><span class="line">//使用静态颜色绘制</span><br><span class="line">  self.baseEffect.useConstantColor = GL_TRUE;</span><br><span class="line">//设置默认绘制颜色，参数分别是 RGBA</span><br><span class="line">  self.baseEffect.constantColor = GLKVector4Make(1.0f, 1.0f, 1.0f, 1.0f);</span><br><span class="line">   //设置背景色为黑色</span><br><span class="line">   glClearColor(0.0f,0.0f,0.0f,1.0f);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>GLKBaseEffect使我们不需要编写shader Language代码就可以简单完成图形绘制，关于Shader Language后面再讲解学习</p>
</blockquote>
<ol start="3">
<li>顶点数据<br>我们需要绘制一个三角形自然需要三个顶点，OpenGL ES采用的笛卡尔坐标系<br><img src="http://upload-images.jianshu.io/upload_images/1320629-79eab7d8ddba623f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OPENGL ES坐标系"></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//顶点结构体</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    GLKVector3 positionCoords;</span><br><span class="line">&#125;sceneVertex;</span><br><span class="line"></span><br><span class="line">//三角形的三个顶点</span><br><span class="line">static const sceneVertex vertices[] = &#123;</span><br><span class="line">    &#123;&#123;-0.5f,-0.5f,0.0&#125;&#125;,</span><br><span class="line">    &#123;&#123;0.5f,-0.5f,0.0&#125;&#125;,</span><br><span class="line">    &#123;&#123;-0.5f,0.5f,0.0&#125;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>生成缓存并且为缓存提供数据，这是最重要的一步</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//声明缓存ID属性</span><br><span class="line">@property (nonatomic,assign)GLuint *vertextBufferID;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//viewdidload中生成并绑定缓存数据</span><br><span class="line">glGenBuffers(1, &amp;vertextBufferID);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, vertextBufferID); //绑定指定标识符的缓存为当前缓存</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure>
<ul>
<li>glGenBuffers申请一个标识符</li>
<li>glBindBuffer 将标识符绑定到GL_ARRAY_BUFFER</li>
<li>glBufferData复制顶点数据从CPU到GPU</li>
</ul>
<p>接下来在GLKViewController的<br>-(void)glkView:(GLKView *)view drawInRect:(CGRect)rect<br>代理方法中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (void)glkView:(GLKView *)view drawInRect:(CGRect)rect&#123;</span><br><span class="line">    [self.baseEffect prepareToDraw];</span><br><span class="line">    </span><br><span class="line">    //Clear Frame Buffer</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    </span><br><span class="line">    //开启缓存</span><br><span class="line">    glEnableVertexAttribArray(GLKVertexAttribPosition);</span><br><span class="line">    </span><br><span class="line">    //设置缓存数据指针</span><br><span class="line">    glVertexAttribPointer(GLKVertexAttribPosition,</span><br><span class="line">                          3,</span><br><span class="line">                          GL_FLOAT,</span><br><span class="line">                          GL_FALSE, //小数点固定数据是否被改变</span><br><span class="line">                          sizeof(sceneVertex),</span><br><span class="line">                          NULL);  //从开始位置</span><br><span class="line">    //绘图</span><br><span class="line">    glDrawArrays(GL_TRIANGLES,</span><br><span class="line">                 0,</span><br><span class="line">                 3);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>glEnableVertexAttribArray 开启对应的顶点缓存属性</li>
<li>glVertexAttribPointer 设置指针从顶点数组中读取数据</li>
<li>glDrawArrays 绘制图形</li>
</ul>
<ol start="5">
<li>释放缓存数据<br>在dealloc方法中释放掉缓存数据</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc&#123;</span><br><span class="line">    GLKView *view = (GLKView *)self.view;</span><br><span class="line">    [EAGLContext setCurrentContext:view.context];</span><br><span class="line">    if ( 0 != vertextBufferID) &#123;</span><br><span class="line">        glDeleteBuffers(1,</span><br><span class="line">                        &amp;vertextBufferID);</span><br><span class="line">        vertextBufferID = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后的运行结果图如下<br><img src="http://upload-images.jianshu.io/upload_images/1320629-131924db984624e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"></p>
<blockquote>
<p>拓展小问题：1. 如何将背景色改成红色  2. 如何将三角形颜色改成黑色，而不是现在的白色</p>
</blockquote>
<ul>
<li>(void)glkView:(GLKView *)view drawInRect:(CGRect)rect是GLKViewController系统给我们回调的绘制消息，该方法会一直被调用，和display方法一致</li>
</ul>
<p>EAGLContext上下文本质上是个状态机，只有在当前上下文下，Opengl ES API调用才会生效</p>
<h1 id="总结：创建缓存数据并完成最终渲染显示的七个步骤"><a href="#总结：创建缓存数据并完成最终渲染显示的七个步骤" class="headerlink" title="总结：创建缓存数据并完成最终渲染显示的七个步骤"></a>总结：创建缓存数据并完成最终渲染显示的七个步骤</h1><ol>
<li>生成: glGenBuffers()</li>
<li>绑定缓存数据: glBindBuffer()</li>
<li>缓存数据:glBufferData()</li>
<li>启用:glEnableVertexAttribArray()</li>
<li>设置指针:glVertexAttribPointer()</li>
<li>绘图:glDrawArrays()</li>
<li>删除:glDeleteBuffers()</li>
</ol>
<blockquote>
<p>好了，就此我们就使用OpenGL ES完成了一个最简单的绘制demo，初次学习OpenGL ES肯定对其中概念会有很多疑问，这都没关系，我们先熟悉一下，随着后续的学习再回来看这些疑问。</p>
</blockquote>
<p>2018-0413更新：<br>Demo代码地址：<a href="https://github.com/AceDong0803/LearnOpenGLESDemo/tree/master" target="_blank" rel="noopener">LearnOpenGLESDemo</a></p>
<p>参考书籍：1. <a href="https://book.douban.com/subject/24849591/" target="_blank" rel="noopener">OpenGL ES应用开发实践指南：iOS卷</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/03/iOS-音频-AVAudioSession/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ace Dong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安东的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/03/iOS-音频-AVAudioSession/" itemprop="url">iOS-音频-AVAudioSession</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-03T22:15:05+08:00">
                2018-02-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="AVAudioSession-概述"><a href="#AVAudioSession-概述" class="headerlink" title="AVAudioSession 概述"></a>AVAudioSession 概述</h1><p>  最近一年一直在做IPC Camera的iOS客户端开发。和音频打交道，必须要弄清楚<br> AVAudioSession。<br>先看下苹果的官方图：<br><img src="http://upload-images.jianshu.io/upload_images/1320629-cfd1eacecf2cacae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Audio Session"></p>
<p>可以看到AVAudioSession就是用来管理多个APP对音频硬件设备（麦克风，扬声器）的资源使用。</p>
<p>举例一下AVAudioSession可以做这些事情</p>
<ul>
<li>设置自己的APP是否和其他APP音频同时存在，还是中断其他APP声音</li>
<li>在手机调到静音模式下，自己的APP音频是否可以播放出声音</li>
<li>电话或者其他APP中断自己APP的音频的事件处理</li>
<li>指定音频输入和输出的设备（比如是听筒输出声音，还是扬声器输出声音）</li>
<li>是否支持录音，录音同时是否支持音频播放</li>
</ul>
<h1 id="AVAudioSession-Category"><a href="#AVAudioSession-Category" class="headerlink" title="AVAudioSession Category"></a>AVAudioSession Category</h1><p>AVAudioSession的接口比较简单。APP启动的时候会自动帮激活AVAudioSession，当然我们可以手动激活代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//导入头文件</span><br><span class="line">#import &lt;AVFoundation/AVFoundation.h&gt;</span><br><span class="line"></span><br><span class="line">//AVAudioSession是一个单例类</span><br><span class="line">AVAudioSession *session = [AVAudioSession sharedInstance];</span><br><span class="line">//AVAudioSessionCategorySoloAmbient是系统默认的category</span><br><span class="line">[session setCategory:AVAudioSessionCategorySoloAmbient error:nil];</span><br><span class="line">//激活AVAudioSession</span><br><span class="line">[session setActive:YES error:nil];</span><br></pre></td></tr></table></figure>
<p>可以看到设置session这里有两个参数，category和options<br>Category iOS下目前有七种，每种Category都对应是否支持下面四种能力</p>
<ul>
<li>Interrupts non-mixable apps audio：是否打断不支持混音播放的APP</li>
<li>Silenced by the Silent switch：是否会响应手机静音键开关</li>
<li>Supports audio input：是否支持音频录制</li>
<li>Supports audio output：是否支持音频播放</li>
</ul>
<p>下面用图表来直观的看下每种category具体的能力集</p>
<table>
<thead>
<tr>
<th>Category</th>
<th style="text-align:center">是否允许音频播放/录音</th>
<th style="text-align:center">是否打断其他不支持混音APP</th>
<th style="text-align:center">是否会被静音键或锁屏键静音</th>
</tr>
</thead>
<tbody>
<tr>
<td>AVAudioSessionCategoryAmbient</td>
<td style="text-align:center">只支持播放</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td>AVAudioSessionCategoryAudioProcessing</td>
<td style="text-align:center">不支持播放，不支持录制</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td>AVAudioSessionCategoryMultiRoute</td>
<td style="text-align:center">支持播放，支持录制</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td>AVAudioSessionCategoryPlayAndRecord</td>
<td style="text-align:center">支持播放，支持录制</td>
<td style="text-align:center">默认YES，可以重写为NO</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td>AVAudioSessionCategoryPlayback</td>
<td style="text-align:center">只支持播放</td>
<td style="text-align:center">默认YES，可以重写为NO</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td>AVAudioSessionCategoryRecord</td>
<td style="text-align:center">只支持录制</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否（锁屏下仍可录制）</td>
</tr>
<tr>
<td>AVAudioSessionCategorySoloAmbient</td>
<td style="text-align:center">只支持播放</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
</tbody>
</table>
<ul>
<li><p>AVAudioSessionCategoryAmbient，只支持音频播放。这个 Category，音频会被静音键和锁屏键静音。并且不会打断其他应用的音频播放。</p>
</li>
<li><p>AVAudioSessionCategorySoloAmbient，这个是系统默认使用的 Category，只支持音频播放。音频会被静音键和锁屏键静音。和AVAudioSessionCategoryAmbient不同的是，这个会打断其他应用的音频播放</p>
</li>
<li><p>AVAudioSessionCategoryPlayback，只支持音频播放。你的音频不会被静音键和锁屏键静音。适用于音频是主要功能的APP，像网易云这些音乐app，锁屏后依然可以播放。</p>
</li>
</ul>
<blockquote>
<p>需要注意一下，选择支持在静音键切到静音状态以及锁屏键切到锁屏状态下仍然可以播放音频 Category 时，必须在应用中开启支持后台音频功能，详见 <a href="https://developer.apple.com/library/ios/documentation/General/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW22" target="_blank" rel="noopener">UIBackgroundModes</a>。</p>
</blockquote>
<ul>
<li>AVAudioSessionCategoryRecord，只支持音频录制。不支持播放。</li>
<li>AVAudioSessionCategoryPlayAndRecord，支持音频播放和录制。音频的输入和输出不需要同步进行，也可以同步进行。需要音频通话类应用，可以使用这个 Category。</li>
<li>AVAudioSessionCategoryAudioProcessing，只支持本地音频编解码处理。不支持播放和录制。</li>
<li>AVAudioSessionCategoryMultiRoute，支持音频播放和录制。允许多条音频流的同步输入和输出。（比如USB连接外部扬声器输出音频，蓝牙耳机同时播放另一路音频这种特殊需求）</li>
</ul>
<p>我们也可以通过AVAudioSession的属性来读取当前设备支持的Category</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(readonly) NSArray&lt;NSString *&gt; *availableCategories;</span><br></pre></td></tr></table></figure>
<p>这样可以保证设备兼容性。</p>
<p>设置Category的代码示例如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSError *setCategoryError = nil;</span><br><span class="line">BOOL isSuccess = [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryAmbient error:&amp;setCategoryError];</span><br><span class="line">if (!success) &#123; </span><br><span class="line">    //这里可以读取setCategoryError.localizedDescription查看错误原因</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="AVAudioSession-Mode-amp-amp-Options"><a href="#AVAudioSession-Mode-amp-amp-Options" class="headerlink" title="AVAudioSession Mode&amp;&amp;Options"></a>AVAudioSession Mode&amp;&amp;Options</h1><p>刚刚介绍的Category定义了七种主场景，实际开发需求中有时候需要对Category进行微调整，我们发现这个接口还有两个参数Mode和Options。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* set session category and mode with options */</span><br><span class="line">- (BOOL)setCategory:(NSString *)category mode:(NSString *)mode options:(AVAudioSessionCategoryOptions)options error:(NSError **)outError API_AVAILABLE(ios(10.0), watchos(3.0), tvos(10.0));</span><br></pre></td></tr></table></figure>
<h3 id="AVAudioSession-Mode"><a href="#AVAudioSession-Mode" class="headerlink" title="AVAudioSession Mode"></a>AVAudioSession Mode</h3><p>我们通过读取下面这条属性获取当前设备支持的Mode</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(readonly) NSArray&lt;NSString *&gt; *availableModes;</span><br></pre></td></tr></table></figure>
<p>iOS下有七种mode来定制我们的Category行为</p>
<table>
<thead>
<tr>
<th>模式</th>
<th style="text-align:center">兼容的 Category</th>
<th style="text-align:center">场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>AVAudioSessionModeDefault</td>
<td style="text-align:center">All</td>
<td style="text-align:center">默认模式</td>
</tr>
<tr>
<td>AVAudioSessionModeVoiceChat</td>
<td style="text-align:center">AVAudioSessionCategoryPlayAndRecord</td>
<td style="text-align:center">VoIP</td>
</tr>
<tr>
<td>AVAudioSessionModeGameChat</td>
<td style="text-align:center">AVAudioSessionCategoryPlayAndRecord</td>
<td style="text-align:center">游戏录制，GKVoiceChat自动设置</td>
</tr>
<tr>
<td>AVAudioSessionModeVideoRecording</td>
<td style="text-align:center">AVAudioSessionCategoryPlayAndRecord AVAudioSessionCategoryRecord</td>
<td style="text-align:center">录制视频</td>
</tr>
<tr>
<td>AVAudioSessionModeMoviePlayback</td>
<td style="text-align:center">AVAudioSessionCategoryPlayback</td>
<td style="text-align:center">视频播放</td>
</tr>
<tr>
<td>AVAudioSessionModeMeasurement</td>
<td style="text-align:center">AVAudioSessionCategoryPlayAndRecord AVAudioSessionCategoryRecord AVAudioSessionCategoryPlayback</td>
<td style="text-align:center">最小系统</td>
</tr>
<tr>
<td>AVAudioSessionModeVideoChat</td>
<td style="text-align:center">AVAudioSessionCategoryPlayAndRecord</td>
<td style="text-align:center">视频通话</td>
</tr>
</tbody>
</table>
<p>下面逐一介绍下每个Mode</p>
<ul>
<li><p>AVAudioSessionModeDefault，默认模式,与所有的 Category 兼容</p>
</li>
<li><p>AVAudioSessionModeVoiceChat，适用于VoIP 类型的应用。只能是 AVAudioSessionCategoryPlayAndRecord Category下。在这个模式系统会自动配置AVAudioSessionCategoryOptionAllowBluetooth 这个选项。系统会自动选择最佳的内置麦克风组合支持语音聊天。</p>
</li>
<li><p>AVAudioSessionModeVideoChat，用于视频聊天类型应用，只能是 AVAudioSessionCategoryPlayAndRecord Category下。适在这个模式系统会自动配置 AVAudioSessionCategoryOptionAllowBluetooth 和 AVAudioSessionCategoryOptionDefaultToSpeaker 选项。系统会自动选择最佳的内置麦克风组合支持视频聊天。</p>
</li>
<li>AVAudioSessionModeGameChat，适用于游戏类应用。使用 GKVoiceChat 对象的应用会自动设置这个模式和 AVAudioSessionCategoryPlayAndRecord Category。实际参数和AVAudioSessionModeVideoChat一致</li>
<li>AVAudioSessionModeVideoRecording，适用于使用摄像头采集视频的应用。只能是 AVAudioSessionCategoryPlayAndRecord 和 AVAudioSessionCategoryRecord 这两个 Category下。这个模式搭配 AVCaptureSession API 结合来用可以更好地控制音视频的输入输出路径。(例如，设置 automaticallyConfiguresApplicationAudioSession 属性，系统会自动选择最佳输出路径。</li>
<li>AVAudioSessionModeMeasurement，最小化系统。只用于 AVAudioSessionCategoryPlayAndRecord、AVAudioSessionCategoryRecord、AVAudioSessionCategoryPlayback 这几种 Category。</li>
<li>AVAudioSessionModeMoviePlayback，适用于播放视频的应用。只用于 AVAudioSessionCategoryPlayback 这个Category。</li>
</ul>
<h3 id="AVAudioSession-Options"><a href="#AVAudioSession-Options" class="headerlink" title="AVAudioSession Options"></a>AVAudioSession Options</h3><p>我们还可以使用options去微调Category行为，如下表</p>
<table>
<thead>
<tr>
<th>Option</th>
<th style="text-align:center">Option功能说明</th>
<th style="text-align:center">兼容的 Category</th>
</tr>
</thead>
<tbody>
<tr>
<td>AVAudioSessionCategoryOptionMixWithOthers</td>
<td style="text-align:center">支持和其他APP音频 mix</td>
<td style="text-align:center">AVAudioSessionCategoryPlayAndRecord AVAudioSessionCategoryPlayback AVAudioSessionCategoryMultiRoute</td>
</tr>
<tr>
<td>AVAudioSessionCategoryOptionDuckOthers</td>
<td style="text-align:center">系统智能调低其他APP音频音量</td>
<td style="text-align:center">AVAudioSessionCategoryPlayAndRecord AVAudioSessionCategoryPlayback AVAudioSessionCategoryMultiRoute</td>
</tr>
<tr>
<td>AVAudioSessionCategoryOptionAllowBluetooth</td>
<td style="text-align:center">支持蓝牙音频输入</td>
<td style="text-align:center">AVAudioSessionCategoryRecord AVAudioSessionCategoryPlayAndRecord</td>
</tr>
</tbody>
</table>
<p>AVAudioSessionCategoryOptionDefaultToSpeaker|    设置默认输出音频到扬声器|    AVAudioSessionCategoryPlayAndRecord|</p>
<h3 id="调优我们的Category"><a href="#调优我们的Category" class="headerlink" title="调优我们的Category"></a>调优我们的Category</h3><p>通过Category和合适的Mode和Options的搭配我们可以调优出我们的效果，下面举两个应用场景:</p>
<p>用过高德地图的都知道，在后台播放QQ音乐的时候，如果导航语音出来，QQ音乐不会停止，而是被智能压低和混音，等导航语音播报完后，QQ音乐正常播放，这里我们需要后台播放音乐，所以Category使用AVAudioSessionCategoryPlayback，需要混音和智能压低其他APP音量，所以Options选用 AVAudioSessionCategoryOptionMixWithOthers和AVAudioSessionCategoryOptionDuckOthers</p>
<p>代码示例如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL isSuccess = [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayback withOptions:AVAudioSessionCategoryOptionMixWithOthers | AVAudioSessionCategoryOptionDuckOthers error:&amp;setCategoryError];</span><br></pre></td></tr></table></figure>
<p>又或者我希望AVAudioSessionCategoryPlayAndRecord这个Category默认的音频由扬声器播放，那么可以调用这个接口去调整Category</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)setCategory:(NSString *)category withOptions:(AVAudioSessionCategoryOptions)options error:(NSError **)outError</span><br></pre></td></tr></table></figure>
<p>通过选择合适和Category，mode和options，就可以调优音频的输入输出，来满足日常开发需求（需要注意的是Category，mode，option是搭配使用的，而不是简单组合，也就是说某种Category支持某些mode和option，从上面的表中也可以看出这一点）</p>
<h1 id="音频中断处理"><a href="#音频中断处理" class="headerlink" title="音频中断处理"></a>音频中断处理</h1><p>其他APP或者电话会中断我们的APP音频，所以相应的我们要做出处理。<br>我们可以通过监听AVAudioSessionInterruptionNotification这个key获取音频中断事件</p>
<p>回调回来Userinfo有键值</p>
<ul>
<li>AVAudioSessionInterruptionTypeKey：<br>取值AVAudioSessionInterruptionTypeBegan表示中断开始<br>取值AVAudioSessionInterruptionTypeEnded表示中断结束</li>
</ul>
<p>中断开始：我们需要做的是保存好播放状态，上下文，更新用户界面等<br>中断结束：我们要做的是恢复好状态和上下文，更新用户界面，根据需求准备好之后选择是否激活我们session。</p>
<p>选择不同的音频播放技术，处理中断方式也有差别，具体如下:</p>
<ul>
<li><p>System Sound Services：使用 System Sound Services 播发音频，系统会自动处理，不受APP控制，当中断发生时，音频播放会静音，当中断结束后，音频播放会恢复。</p>
</li>
<li><p>AV Foundation framework：AVAudioPlayer 类和 AVAudioRecorder 类提供了中断开始和结束的 Delegate 回调方法来处理中断。中断发生，系统会自动停止播放，需要做的是记录播放时间等状态，更新用户界面，等中断结束后，再次调用播放方法，系统会自动激活session。</p>
</li>
<li><p>Audio Queue Services, I/O audio unit：使用aduio unit这些技术需要处理中断，需要做的是记录播放或者录制的位置，中断结束后自己恢复audio session。</p>
</li>
<li><p>OpenAL：使用 OpenAL 播放时，同样需要自己监听中断。管理 OpenAL上下文，用户中断结束后恢复audio session。</p>
</li>
</ul>
<blockquote>
<p>需要注意的是：1. 有中断开始事件，不一定对应有中断结束事件，所以需要在用户进入前台，点击UI操作的时候，需要保存好播放状态和对Audio Session管理，以便不影响APP的音频功能。2.音频资源竞争上，一定是电话优先。3. AVAudioSession同样可以监听外设音频状态，比如耳机拔入拔出。这里不做累述</p>
</blockquote>
<h1 id="AVAudioSession总结"><a href="#AVAudioSession总结" class="headerlink" title="AVAudioSession总结"></a>AVAudioSession总结</h1><p>AVAudioSession的作用就是管理音频这一唯一硬件资源的分配，通过调优合适的AVAudioSession来适配我们的APP对于音频的功能需求。切换音频场景时候，需要相应的切换AVAudioSession。</p>
<p>参考文献：<a href="https://developer.apple.com/library/content/documentation/Audio/Conceptual/AudioSessionProgrammingGuide/Introduction/Introduction.html" target="_blank" rel="noopener">Audio Session Programming Guide</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/17/过好自己的二十几岁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ace Dong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安东的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/17/过好自己的二十几岁/" itemprop="url">过好自己的二十几岁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-17T22:08:05+08:00">
                2017-06-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>昨天下班坐地铁看到一位年轻妈妈带着一个三四岁大的小盆友，于是就给他们让了座，妈妈立马很有礼貌的教着小盆友说：”谢谢叔叔。” “叔叔？” 不禁思忖了下：什么时候开始从叫哥哥变成叫叔叔的呢？</p>
</blockquote>
<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面:"></a>写在前面:</h1><p>岁月如歌,又是一年毕业季，作者已经毕业四年有余，即将奔三。从那个刚入社会的黄毛小子到规规矩矩的上班族。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1320629-517c496979c0a484.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""></p>
<h1 id="好好工作："><a href="#好好工作：" class="headerlink" title="好好工作："></a>好好工作：</h1><blockquote>
<p>毕业四年，换了四份工作。<br>    换工作可以有各式各样的理由：行业没前景，重复枯燥，没有技术含量，待遇不给力，加班太多，公司文化不人性化等等。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1320629-7e32a867c5cf5685.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""></p>
<ol>
<li><p>尽管工作不满意，不把抱怨挂嘴边。<br>待过的每个公司都有“祥林嫂”这样的角色。抱怨这个不人性化，那个福利不好。其实嘴边的抱怨不会起到任何正面作用，还会把负面情绪感染到其他人。与其不停抱怨，不如采取一些实际有效的行动，和公司领导有效沟通解决问题，提升自我，换取更好平台等等。</p>
</li>
<li><p>入错行<br>男怕入错行，进入一个看不到前景的行业，是一件很痛苦的事情。作者待的第一家公司业务也算是夕阳行业。最终经过了大半年的准备和酝酿，才跳槽换行。尽管过程很痛苦，庆幸没有让时间磨去了锐气。</p>
</li>
<li><p>“假装”对工作有兴趣<br>卡耐基在&lt;&lt;人性的弱点&gt;&gt;中提到：如果你“假装”对工作有兴趣，一点假装就会使你的兴趣成真，可以减少你的疲劳。（尽管作者不完全认同卡耐基的观点。至少保持乐观开心的心态去工作，会让你更加舒服。哈哈哈。心理胜利法。）</p>
</li>
<li><p>放低姿态，换位思考<br>公司不是家，特别是有着完善流程的大型企业，离开了谁都可以转，所以把自己放低，不要以自我为中心。<br>多多换位思考。</p>
</li>
<li><p>时刻有着一颗创业的心<br>作者还没有创业的经历，需要一个好的想法，一个未来可期的方案。就是这样。时刻准备着。</p>
</li>
</ol>
<h1 id="好好生活"><a href="#好好生活" class="headerlink" title="好好生活"></a>好好生活</h1><blockquote>
<p>不知道从什么时候开始，聚餐的时候老板问喝什么的时候，都会不假思索的回答：就喝茶水吧，谢谢。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1320629-a857b2275fbf3950.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""></p>
<ol>
<li><p>零点前入睡<br> 尽管现实工作经常996，每天零点前就入睡。身体才是革命的本钱。</p>
</li>
<li><p>抽出一点时间去运动<br> 毕业后身材有些走样，大有快速老年化趋势。养成每天花半个小时到一个小时去慢跑，去打打球，游游泳的好习惯。不求有个型男的身材，至少也能维持身体健壮吧。事实上运动还能给自己带来了许多的快乐。</p>
</li>
<li><p>参加户外旅行<br> “身体和灵魂总有一个要在路上”，喜欢和三两好友安静的周边游，爬爬山，看看花花草草，山山水水，也喜欢组团去各地的风景名胜，和五湖四海的好友聊聊天，品味风土人情。</p>
</li>
<li><p>多关心家人<br> 父母渐渐地年纪也大了，时常和父母通通电话，给爸妈购买点贴心的小物品，尽管父母又会抱怨乱花钱，但是心里还是开心的。漂泊在外，报喜不报忧吧。</p>
</li>
<li><p>乐观上进的心态<br> 毕业之后，一直在深圳工作，尽管在快节奏和高房价的压力之下。很开心的是一直有着乐观的心态。但尽人事，莫问前程。每天让自己变得好一点，就是进步。</p>
</li>
<li><p>读读书<br> 杨绛先生说过：〝年轻的时候以为不读书不足以了解人生，直到后来才发现如果不了解人生，是读不懂书的。〞刚毕业的时候不喜欢读书，耐不住性子。直到最近一年才慢慢的养成了读书的习惯。<br>“一花一世界，一叶一菩提”。</p>
</li>
</ol>
<h1 id="关于爱情，不忘初心"><a href="#关于爱情，不忘初心" class="headerlink" title="关于爱情，不忘初心"></a>关于爱情，不忘初心</h1><blockquote>
<p>如果有一天我结婚了，那一定是因为爱情。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1320629-4811da96533c1707.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>不管过去怎样，作为一名资深单身🐶，已经过了一见钟情的年纪，不再会看到颜值高的妹子就想着去撩一下。更多的去感受实实在在的相处。</p>
<p>理想中的爱情<br>始于颜值，敬于才华，合于性格。久于善良，终于人品。<br>不忘初心，方得始终。</p>
<h1 id="写在结尾"><a href="#写在结尾" class="headerlink" title="写在结尾"></a>写在结尾</h1><p>作家东野奎吾曾经写道：”人生而残缺，却无往不在寻找完整，人生而孤独，却无往不在寻找羁绊。”</p>
<p>最好的年纪，最好的岁月，认真过好每一天，相信一切都是最好的安排。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/06/10/iOS多线程编程之GCD详解（二）完结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ace Dong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安东的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/06/10/iOS多线程编程之GCD详解（二）完结/" itemprop="url">iOS多线程编程之GCD详解（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-06-10T19:08:05+08:00">
                2015-06-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇详细介绍了介绍了GCD中的常用API，<br>考虑到篇幅问题，这里继续介绍另外的两个API。</p>
<h1 id="Dispatch-Semaphore-信号量"><a href="#Dispatch-Semaphore-信号量" class="headerlink" title="Dispatch Semaphore 信号量"></a>Dispatch Semaphore 信号量</h1><p><code>dispatch_semaphore_t</code> 信号量本质上是一种锁。<br>关于iOS中各种锁和性能比较可以看下yykit作者的这篇博文，戳这里<br><a href="http://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的 OSSpinLock</a></p>
<p>下面我们看下信号量的使用:<br><code>dispatch_semaphore_t</code>  的作用之一解决资源抢夺问题<br>之前提过，对于数据存储类似数据库，非原子性可变字典和可变数组等多线程下不安全的操作，可以使用同步队列保证线程安全，那么在并发队列中，可以使用信号量来解决资源抢夺问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//全局队列</span><br><span class="line">  dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">  //创建一个信号量，初始值为1</span><br><span class="line">  dispatch_semaphore_t semaphore = dispatch_semaphore_create(1) ;</span><br><span class="line">  //创建可变数组</span><br><span class="line">  NSMutableArray *array = [[NSMutableArray alloc] init];</span><br><span class="line">  for(int i = 0; i&lt; 1000; ++i) &#123;</span><br><span class="line">      dispatch_async(queue, ^&#123;</span><br><span class="line">          </span><br><span class="line">          //这里会一直等待，直到信号量大于等于1</span><br><span class="line">          dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER) ;</span><br><span class="line">          </span><br><span class="line">          //执行到这里，消费一个信号量</span><br><span class="line">          NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">          [array addObject:[NSNumber numberWithInt:i]];</span><br><span class="line">          </span><br><span class="line">          //这里增加一个信号量</span><br><span class="line">          dispatch_semaphore_signal(semaphore);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>代码解读一下:<br><code>dispatch_semaphore_create(1)</code> 创建了值为1信号量<br><code>dispatch_semaphore_wait</code> ，如果信号量的值大于等于1，那么，信号量值减1，然后向下执行，如果信号量值为0，一直等待。直到大于等于1的时候，率先进入等待状态的异步队列率先执行<br><code>dispatch_semaphore_signal</code> 信号量值加1</p>
<p>形象比喻一下:<br>一群人排队去银行办业务，银行初始只有一个窗口，第一个人办业务的时候,可用窗口就变成0个了，这个人办完业务，可用窗口加1，就变成1个了。</p>
<p>实际这种效果和加锁的本质一致。<br><code>dispatch_semaphore_t</code>  的另外一个作用就是可以控制线程并发数量，之前我们提过，iOS7之后系统自动开辟的线程数量可以多达60-70，而GCD中并没有提供控制线程数量的API，NSOperation中可以设置最大线程数。</p>
<p>下面我们使用信号量来实现一下线程数量控制:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//线程并发数限制</span><br><span class="line">static dispatch_semaphore_t limitSemaphore;</span><br><span class="line">//控制专用队列</span><br><span class="line">static dispatch_queue_t serialQueue;</span><br><span class="line"></span><br><span class="line">//单例创建</span><br><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">  //设置最大线程并发数为5</span><br><span class="line">    limitCount = dispatch_semaphore_create(5);</span><br><span class="line">    serialQueue = dispatch_queue_create(&quot;serial&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(serialQueue, ^&#123;</span><br><span class="line">    //信号量&gt;=1继续执行，否则等待</span><br><span class="line">    dispatch_semaphore_wait(limitSemaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        //这里执行一些任务</span><br><span class="line">        NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">        //在该工作线程执行完成后释放信号量</span><br><span class="line">        dispatch_semaphore_signal(limitSemaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="dispatch-source"><a href="#dispatch-source" class="headerlink" title="dispatch source"></a>dispatch source</h1><p><code>dispatch source</code> 是一组不常用的GCD API。是BSD系内核惯有功能kqueue的包装。kqueue的介绍可以看下这个<a href="https://en.wikipedia.org/wiki/Kqueue" target="_blank" rel="noopener">kqueue wikipedia</a><br>简单来说，dispatch source是一个监视某些类型事件的对象。它支持所有kqueue所支持的事件以及mach（mach介绍可以看这里<a href="http://en.wikipedia.org/wiki/Mach_(kernel" target="_blank" rel="noopener">mach wikipedia</a>)）端口、内建计时器支持和用户事件，CPU负荷占用小，资源占用小。</p>
<p><code>dispatch source</code>联结</p>
<p>联结的流程：在任一线程上调用dispatch_source_merge_data 这个函数后，会执行 Dispatch Source 事先定义好的句柄（可以简单理解句柄就是block ）（是不是有点通知，回调的味道哈）<br>下面直接上代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//全局队列</span><br><span class="line"> dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">//创建source</span><br><span class="line">    dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, dispatch_get_main_queue());</span><br><span class="line">//定义source的句柄</span><br><span class="line">    dispatch_source_set_event_handler(source, ^&#123;</span><br><span class="line">//调用一次dispatch_source_merge_data会调用这个句柄</span><br><span class="line">        NSLog(@&quot;%lu&quot;,dispatch_source_get_data(source));</span><br><span class="line">    &#125;);</span><br><span class="line">    //默认source是suspend的，需要resume生效</span><br><span class="line">    dispatch_resume(source);</span><br><span class="line">    </span><br><span class="line">//遍历10次</span><br><span class="line">    dispatch_apply(10, globalQueue, ^(size_t index) &#123;</span><br><span class="line">        // merge data</span><br><span class="line">        dispatch_source_merge_data(source, 1);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>这段程序简单逻辑:调用<code>dispatch_source_merge_data</code> 会触发实现定义好的事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_source_set_event_handler(source, ^&#123;</span><br><span class="line">//调用一次dispatch_source_merge_data会调用这个句柄</span><br><span class="line">        NSLog(@&quot;%lu&quot;,dispatch_source_get_data(source));</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p><code>dispatch_source_create</code> 函数参数</p>
<p><code>DISPATCH_SOURCE_TYPE_DATA_ADD</code> 累加<br>当注册系统事件的时候，有时候系统还没来得及通知应用程序，这个时候，系统会累计传递过来的值</p>
<p><code>DISPATCH_SOURCE_TYPE_DATA_OR</code> 逻辑或处理累计传递过来的值</p>
<p>其他:</p>
<p><code>DISPATCH_SOURCE_TYPE_MACH_SEND</code>MACH端口发送<br><code>DISPATCH_SOURCE_TYPE_MACH_RECV</code>    MACH端口接收<br><code>DISPATCH_SOURCE_TYPE_PROC</code>    监测进程相关事件<br><code>DISPATCH_SOURCE_TYPE_READ</code>    可读取文件映像<br><code>DISPATCH_SOURCE_TYPE_SIGNAL</code>    接收信号<br><code>DISPATCH_SOURCE_TYPE_TIMER</code>    定时器<br><code>DISPATCH_SOURCE_TYPE_VNODE</code>    文件系统变更<br><code>DISPATCH_SOURCE_TYPE_WRITE</code>    可写入文件映像</p>
<p>注册事件处理程序通知，如果系统没来的及通知应用程序时候事件发生多次，这些事件会合并为一个事件(是不是类似于TCP协议中的nagle算法)。iOS开发者通常不会用到这种功能。但对于底层，这种处理方式会很高效.</p>
<p>简单流程总结:创建一个源，自定义累计方式，可以是and也可以是Or，自定义源也需要一个队列用来处理响应块，可以是主队列，也可以是并发队列。</p>
<p>在同一时间，只有一个响应块被分派。处理方法没执行完毕，另一个事件发生，事件以指定方式(ADD或者OR)进行累积。通过合并，保证了在高负载下稳定执行。<br>累计值通过 <code>dispatch_source_get_data</code> 获取。每次响应执行事件，这个值会被重置<br><code>dispatch_source_merge_data</code> 发送一个事件<br>默认创建出来的source是挂起状态的，需要调用<code>dispatch_resume</code> 才可生效</p>
<p>除了高效的自定义一个source处理自定事件之外，我们也可以使用<code>dispatch_source</code> 来定义一个定时器，iOS开发中常用的定时器有<code>NSTimer</code>  和<code>CADisplayLink</code>  两种<br><code>NSTimer</code> 受到runloop的状态影响精度<br><code>CADisplayLink</code> 则和屏幕刷新度帧数一致<br>而<code>dispatch_source</code> 作为定时器精度很高，是系统级别的源</p>
<p>demo如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">//定时器作为属性创建</span><br><span class="line">     self.timerSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</span><br><span class="line">    //开始时间</span><br><span class="line">    dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW, 3.0 * NSEC_PER_SEC);</span><br><span class="line">    //间隔时间</span><br><span class="line">    uint64_t interval = 2.0 * NSEC_PER_SEC;</span><br><span class="line">  //设置时间</span><br><span class="line">    dispatch_source_set_timer( self.timerSource start, interval, 0);</span><br><span class="line"></span><br><span class="line">    //设置回调</span><br><span class="line">    dispatch_source_set_event_handler( self.timerSource, ^&#123;</span><br><span class="line">        //处理事件</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    //启动定时器</span><br><span class="line">    dispatch_resume( self.timerSource);</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要介绍了</p>
<p><code>dispatch_semaphore_t</code> ，本质是一种底层锁，性能较高，可以用来解决多线程资源竞争，控制线程并发数。</p>
<p><code>dispatch source</code> 最大的优势是联结，通过合并事件的方式，高效的处理事件分派，可以自定义source用来处理高负载应用场景响应。</p>
<p><code>dispatch source</code> 可以作为高精度，系统源层级的定时器，在需要高精度应用场景下可以选用这种更加接近底层的定时器。</p>
<p>写了两篇博客来详解了下GCD，主要是对自我基础的一个总结。之前已经有很多写的很好的GCD文章。关于信号量和<code>dispatch_source</code>还有兴趣深入了解的可以阅读下官方文档。<br>推荐下阅读猿神的博客<br><a href="http://www.jianshu.com/p/805dd3c16869" target="_blank" rel="noopener">Parse源码浅析系列（一）—Parse的底层多线程处理思路：GCD高级用法</a></p>
<p>参考书籍:<br><a href="http://baike.baidu.com/link?url=8cLEWwOe25Y-Fg2wzOTmOmvwn9Osy7tkkNbMKft-fsX0NJlkCXUKsljKkAh2UK0pFb2zm5hL4vs4w6xgMSgWzw2FGCnTTit_hNdQbDOQIHjHs1BW6e4lUl5qARANbVfyNfqEDP_E_aoVC6tR1kLR2K" target="_blank" rel="noopener">Objective-C高级编程</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/06/03/iOS多线程编程之GCD详解（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ace Dong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安东的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/06/03/iOS多线程编程之GCD详解（一）/" itemprop="url">iOS多线程编程之GCD详解（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-06-03T15:04:46+08:00">
                2015-06-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="GCD简介"><a href="#GCD简介" class="headerlink" title="GCD简介"></a>GCD简介</h1><p>iOS开发中多线程的API主要有pthread，NSThread，NSOperation和GCD，前两者在现在开发过程中已经不常用，NSOperation是面向对象封装的一套API，而GCD则是一套纯C语言API。</p>
<blockquote>
<p>引用下百度的介绍<br>GCD为Grand Central Dispatch的缩写。<br>Grand Central Dispatch (GCD)是Apple开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并行任务。在Mac OS X 10.6雪豹中首次推出，也可在IOS 4及以上版本使用。</p>
</blockquote>
<p><strong>GCD有哪些优点:</strong></p>
<ol>
<li>提供了易于使用的并发模型而不仅仅只是锁和线程，可以让我们轻松的进行多线程编程。</li>
<li>自动利用更多的CPU内核。</li>
<li>自动管理线程的生命周期，以及多线程调度。</li>
<li>提供了简单创建单例的接口等等。</li>
</ol>
<h1 id="Dispatch-Queue（队列）概念"><a href="#Dispatch-Queue（队列）概念" class="headerlink" title="Dispatch_Queue（队列）概念"></a>Dispatch_Queue（队列）概念</h1><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>GCD中的队列和数据结构中的队列特性上一致，都是受限制的线性表，遵循FIFO(First In First Out),即新的任务需要在队尾加入，读取任务则从队首部读取，即先进先出<br> 队列又分为：</p>
<ul>
<li>串行队列（Serial Dispatch Queue）<br>   简单理解串行队列就是按顺序执行一个任务，上一个任务执行完毕后执行下一个任务，现实中的例子，去银行办业务，只有一个窗口，大家有秩序的排队办业务，即是串行队列</li>
<li>并发队列（Concurrent Dispatch Queue）<br>  简单理解并发队列就是同时执行多个任务，现实中的极端例子，去银行排队办业务，有多个窗口同时可以办业务，即是并发队列，需要注意的是，这些任务会按照被添加的顺序依次开始执行。但是任务完成的顺序是任意的。</li>
</ul>
<p>这里提到了“任务”的概念：<br><strong>“任务”</strong>，在 GCD 里指的是 Block，即一段需要执行的代码块<br>任务执行方式有两种：</p>
<ul>
<li><p>同步执行(dispatch_sync)<br>完成任务后才会返回，进行下一任务，可见同步不具备开启线程能力，只会在当前线程依次执行</p>
</li>
<li><p>异步执行(dispatch_async)<br>完成任务后立即返回，进行下一任务，具备多线程能力</p>
</li>
</ul>
<p><strong>总结：</strong>并发队列只会在异步执行下生效，同步执行不会触发多线程创建。</p>
<h1 id="GCD队列编程实现"><a href="#GCD队列编程实现" class="headerlink" title="GCD队列编程实现"></a>GCD队列编程实现</h1><h2 id="创建一个队列"><a href="#创建一个队列" class="headerlink" title="创建一个队列"></a>创建一个队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//串行队列</span><br><span class="line">    dispatch_queue_t serialQueue = dispatch_queue_create(&quot;serialQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line"> //并发队列</span><br><span class="line">    dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;concurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>
<p> <code>dispatch_queue_create</code></p>
<p>创建一个<code>dispatch_queue_t</code>队列，第一个参数设置该队列标识符，用于调试使用，第二个参数，则是队列类型<br><code>DISPATCH_QUEUE_SERIAL</code>串行队列<br><code>DISPATCH_QUEUE_CONCURRENT</code> 并发队列</p>
<p>除了自己创建队列之外，系统提供了两个队列供我们获取使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//主线程队列</span><br><span class="line">dispatch_queue_t mainQueue = dispatch_get_main_queue();</span><br><span class="line"></span><br><span class="line">//全局队列</span><br><span class="line">dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br></pre></td></tr></table></figure>
<ul>
<li>主线程队列：这个是主线程的串行队列</li>
<li>全局队列: 这是个全局的并发队列，很多时候可以不需要自己创建并发队列，直接获取全局队列即可 第一个参数为优先级，这是个大概优先级设置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_QUEUE_PRIORITY_HIGH  //高优先级</span><br><span class="line">DISPATCH_QUEUE_PRIORITY_DEFAULT //默认优先级</span><br><span class="line">DISPATCH_QUEUE_PRIORITY_LOW //低优先级</span><br><span class="line">DISPATCH_QUEUE_PRIORITY_BACKGROUND //后台优先级</span><br></pre></td></tr></table></figure>
<p>接下来即可在队列中添加任务执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//异步执行</span><br><span class="line">dispatch_async(serialQueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;serialQueue中异步执行&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">	</span><br><span class="line">//同步执行</span><br><span class="line">dispatch_sync(serialQueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;serialQueue中同步执行&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里总共有三种类型队列：</p>
<ol>
<li>并发队列（包括全局队列）</li>
<li>串行队列</li>
<li>主线程队列 </li>
</ol>
<p>三种队列分别可以同步异步执行就有6种组合方式</p>
<ul>
<li>主线程同步执行</li>
<li>主线程异步执行</li>
<li>串行队列同步执行</li>
<li>串行队列异步执行</li>
<li>并行队列同步执行</li>
<li>并行队列异步执行</li>
</ul>
<p>接下来我们依次看下每种情况</p>
<h2 id="主线程同步执行"><a href="#主线程同步执行" class="headerlink" title="主线程同步执行"></a>主线程同步执行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;Begin&quot;);</span><br><span class="line">	</span><br><span class="line">//主线程同步同步执行</span><br><span class="line">dispatch_sync(mainQueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;主线程同步同步执行&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">	</span><br><span class="line">NSLog(@&quot;End&quot;);</span><br></pre></td></tr></table></figure>
<p>运行下我们会发现</p>
<blockquote>
<p>2017-05-03 16:50:31.542 GCDDemo[41489:596607] Begin<br>只打印了begin，并没有执行下去<br>事实上这里发生了死锁，<br>之前说过<code>dispatch_sync</code>会等待上一个任务执行完才会执行下一个任务，sync添加的任务需要执行，需要等待<code>NSLog(@&quot;End&quot;);</code>执行完毕，<code>NSLog(@&quot;End&quot;);</code>任务本身也添加在主线程队列中，所以执行这个任务的前提是sync添加的任务执行完毕，这就出现了死锁，两个任务互相等待</p>
</blockquote>
<p> <strong>总结</strong>:</p>
<ol>
<li><strong>主线程中执行同步任务会发生死锁</strong></li>
<li><strong>串行队列中嵌套串行队列任务会发生死锁(这个留给大家自己验证，本质上和主线程同步发生死锁一致)</strong></li>
</ol>
<h2 id="主线程异步执行"><a href="#主线程异步执行" class="headerlink" title="主线程异步执行"></a>主线程异步执行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;Begin&quot;);</span><br><span class="line">//主线程异步执行</span><br><span class="line">dispatch_async(mainQueue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">       NSLog(@&quot;%d---------主线程异步执行%@&quot;, i,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(mainQueue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">        NSLog(@&quot;%d---------主线程异步执行%@&quot;, i,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(mainQueue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">        NSLog(@&quot;%d---------主线程异步执行%@&quot;, i,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;End&quot;);</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<blockquote>
<p>2017-05-03 17:09:26.031 GCDDemo[42671:613068] Begin<br>2017-05-03 17:09:26.031 GCDDemo[42671:613068] End<br>2017-05-03 17:09:26.042 GCDDemo[42671:613068] 0———主线程异步执行&lt;NSThread: 0x60000007d5c0&gt;{number = 1, name = main}<br>2017-05-03 17:09:26.043 GCDDemo[42671:613068] 1———主线程异步执行&lt;NSThread: 0x60000007d5c0&gt;{number = 1, name = main}<br>2017-05-03 17:09:26.044 GCDDemo[42671:613068] 2———主线程异步执行&lt;NSThread: 0x60000007d5c0&gt;{number = 1, name = main}<br>2017-05-03 17:09:26.052 GCDDemo[42671:613068] 0———主线程异步执行&lt;NSThread: 0x60000007d5c0&gt;{number = 1, name = main}<br>2017-05-03 17:09:26.057 GCDDemo[42671:613068] 1———主线程异步执行&lt;NSThread: 0x60000007d5c0&gt;{number = 1, name = main}<br>2017-05-03 17:09:26.059 GCDDemo[42671:613068] 2———主线程异步执行&lt;NSThread: 0x60000007d5c0&gt;{number = 1, name = main}<br>2017-05-03 17:09:26.060 GCDDemo[42671:613068] 0———主线程异步执行&lt;NSThread: 0x60000007d5c0&gt;{number = 1, name = main}<br>2017-05-03 17:09:26.062 GCDDemo[42671:613068] 1———主线程异步执行&lt;NSThread: 0x60000007d5c0&gt;{number = 1, name = main}<br>2017-05-03 17:09:26.063 GCDDemo[42671:613068] 2———主线程异步执行&lt;NSThread: 0x60000007d5c0&gt;{number = 1, name = main}</p>
</blockquote>
<p><strong>总结:</strong></p>
<p><strong>主线程队列异步执行不会开辟线程，会在当前线程同步执行。</strong></p>
<h2 id="串行队列同步执行"><a href="#串行队列同步执行" class="headerlink" title="串行队列同步执行"></a>串行队列同步执行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;Begin&quot;);</span><br><span class="line">//串行队列同步执行</span><br><span class="line">dispatch_sync(serialQueue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">       NSLog(@&quot;%d---------串行队列同步执行%@&quot;, i,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_sync(serialQueue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">        NSLog(@&quot;%d---------串行队列同步执行%@&quot;, i,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_sync(serialQueue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">        NSLog(@&quot;%d---------串行队列同步执行%@&quot;, i,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;End&quot;);</span><br></pre></td></tr></table></figure>
<p>运行结果如下: </p>
<blockquote>
<p>2017-05-03 17:25:48.225 GCDDemo[43694:625941] Begin<br>2017-05-03 17:25:48.225 GCDDemo[43694:625941] 0———串行队列同步执行&lt;NSThread: 0x60800007f880&gt;{number = 1, name = main}<br>2017-05-03 17:25:48.226 GCDDemo[43694:625941] 1———串行队列同步执行&lt;NSThread: 0x60800007f880&gt;{number = 1, name = main}<br>2017-05-03 17:25:48.226 GCDDemo[43694:625941] 2———串行队列同步执行&lt;NSThread: 0x60800007f880&gt;{number = 1, name = main}<br>2017-05-03 17:25:48.226 GCDDemo[43694:625941] 0———串行队列同步执行&lt;NSThread: 0x60800007f880&gt;{number = 1, name = main}<br>2017-05-03 17:25:48.227 GCDDemo[43694:625941] 1———串行队列同步执行&lt;NSThread: 0x60800007f880&gt;{number = 1, name = main}<br>2017-05-03 17:25:48.227 GCDDemo[43694:625941] 2———串行队列同步执行&lt;NSThread: 0x60800007f880&gt;{number = 1, name = main}<br>2017-05-03 17:25:48.227 GCDDemo[43694:625941] 0———串行队列同步执行&lt;NSThread: 0x60800007f880&gt;{number = 1, name = main}<br>2017-05-03 17:25:48.228 GCDDemo[43694:625941] 1———串行队列同步执行&lt;NSThread: 0x60800007f880&gt;{number = 1, name = main}<br>2017-05-03 17:25:48.228 GCDDemo[43694:625941] 2———串行队列同步执行&lt;NSThread: 0x60800007f880&gt;{number = 1, name = main}<br>2017-05-03 17:25:48.228 GCDDemo[43694:625941] End</p>
</blockquote>
<p><strong>总结: 串行队列异步执行不会开辟多线程，只会在一条线程中依次执行</strong></p>
<h2 id="串行队列异步执行"><a href="#串行队列异步执行" class="headerlink" title="串行队列异步执行"></a>串行队列异步执行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;Begin&quot;);</span><br><span class="line">//串行队列异步执行</span><br><span class="line">dispatch_async(serialQueue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">       NSLog(@&quot;%d---------串行队列异步执行%@&quot;, i,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(serialQueue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">        NSLog(@&quot;%d---------串行队列异步执行%@&quot;, i,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch\_async(serialQueue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">        NSLog(@&quot;%d---------串行队列异步执行%@&quot;, i,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;End&quot;);</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<blockquote>
<p>2017-05-03 17:20:16.514 GCDDemo[43349:621375] Begin<br>2017-05-03 17:20:16.514 GCDDemo[43349:621375] End<br>2017-05-03 17:20:16.515 GCDDemo[43349:621680] 0———串行队列异步执行&lt;NSThread: 0x608000268040&gt;{number = 3, name = (null)}<br>2017-05-03 17:20:16.515 GCDDemo[43349:621680] 1———串行队列同步执行&lt;NSThread: 0x608000268040&gt;{number = 3, name = (null)}<br>2017-05-03 17:20:16.515 GCDDemo[43349:621680] 2———串行队列异步执行&lt;NSThread: 0x608000268040&gt;{number = 3, name = (null)}<br>2017-05-03 17:20:16.516 GCDDemo[43349:621680] 0———串行队列异步执行&lt;NSThread: 0x608000268040&gt;{number = 3, name = (null)}<br>2017-05-03 17:20:16.516 GCDDemo[43349:621680] 1———串行队列异步执行&lt;NSThread: 0x608000268040&gt;{number = 3, name = (null)}<br>2017-05-03 17:20:16.516 GCDDemo[43349:621680] 2———串行队列异步执行&lt;NSThread: 0x608000268040&gt;{number = 3, name = (null)}<br>2017-05-03 17:20:16.516 GCDDemo[43349:621680] 0———串行队列异步执行&lt;NSThread: 0x608000268040&gt;{number = 3, name = (null)}<br>2017-05-03 17:20:16.517 GCDDemo[43349:621680] 1———串行队列异步执行&lt;NSThread: 0x608000268040&gt;{number = 3, name = (null)}<br>2017-05-03 17:20:16.517 GCDDemo[43349:621680] 2———串行队列异步执行&lt;NSThread: 0x608000268040&gt;{number = 3, name = (null)}</p>
</blockquote>
<p><strong>总结: 串行队列异步执行不会开辟多线程，只会在一条线程中依次执行</strong></p>
<p>细心的同学会发现串行队列同步和异步执行都没有开辟多线程，在一条线程中同步执行，那么对于串行队列同步和异步执行有什么区别呢?<br>区别只有一点：</p>
<p>dispatch_async：<strong>不会阻塞当前队列</strong>，立即返回添加当前队列后面任务，可以看到上图打印结果，先打印end。再打印async任务</p>
<p>dispatch_sync：<strong>会阻塞当前队列</strong>，等该sync任务全部执行完毕之后再添加当前队列后面任务，可以看到上图打印结果，先打印完sync任务打印end。</p>
<h2 id="并发队列同步执行"><a href="#并发队列同步执行" class="headerlink" title="并发队列同步执行"></a>并发队列同步执行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;Begin&quot;);</span><br><span class="line">//串行队列同步执行</span><br><span class="line">dispatch_sync(concurrentQueue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">       NSLog(@&quot;%d---------并发队列同步执行%@&quot;, i,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_sync(concurrentQueue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">        NSLog(@&quot;%d---------并发队列同步执行%@&quot;, i,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_sync(concurrentQueue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">        NSLog(@&quot;%d---------并发队列同步执行%@&quot;, i,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;End&quot;);</span><br></pre></td></tr></table></figure>
<p>运行结果如下:</p>
<blockquote>
<p>2017-05-03 17:34:24.407 GCDDemo[44222:633000] Begin<br>2017-05-03 17:34:24.407 GCDDemo[44222:633000] 0———并发队列同步执行&lt;NSThread: 0x60800006f380&gt;{number = 1, name = main}<br>2017-05-03 17:34:24.407 GCDDemo[44222:633000] 1———并发队列同步执行&lt;NSThread: 0x60800006f380&gt;{number = 1, name = main}<br>2017-05-03 17:34:24.408 GCDDemo[44222:633000] 2———并发队列同步执行&lt;NSThread: 0x60800006f380&gt;{number = 1, name = main}<br>2017-05-03 17:34:24.408 GCDDemo[44222:633000] 0———并发队列同步执行&lt;NSThread: 0x60800006f380&gt;{number = 1, name = main}<br>2017-05-03 17:34:24.408 GCDDemo[44222:633000] 1———并发队列同步执行&lt;NSThread: 0x60800006f380&gt;{number = 1, name = main}<br>2017-05-03 17:34:24.408 GCDDemo[44222:633000] 2———并发队列同步执行&lt;NSThread: 0x60800006f380&gt;{number = 1, name = main}<br>2017-05-03 17:34:24.408 GCDDemo[44222:633000] 0———并发队列同步执行&lt;NSThread: 0x60800006f380&gt;{number = 1, name = main}<br>2017-05-03 17:34:24.408 GCDDemo[44222:633000] 1———并发队列同步执行&lt;NSThread: 0x60800006f380&gt;{number = 1, name = main}<br>2017-05-03 17:34:24.409 GCDDemo[44222:633000] 2———并发队列同步执行&lt;NSThread: 0x60800006f380&gt;{number = 1, name = main}<br>2017-05-03 17:34:24.410 GCDDemo[44222:633000] End</p>
</blockquote>
<p><strong>总结: 并发队列同步执行不会开辟多线程，只会在一条线程中依次执行</strong></p>
<h2 id="并发队列异步执行"><a href="#并发队列异步执行" class="headerlink" title="并发队列异步执行"></a>并发队列异步执行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;Begin&quot;);</span><br><span class="line">//并发队列异步执行</span><br><span class="line">dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">       NSLog(@&quot;%d---------并发队列异步执行%@&quot;, i,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">        NSLog(@&quot;%d---------并发队列异步执行%@&quot;, i,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">        NSLog(@&quot;%d---------并发队列异步执行%@&quot;, i,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;End&quot;);</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<blockquote>
<p>2017-05-03 17:38:10.893 GCDDemo[44461:636216] Begin<br>2017-05-03 17:38:10.894 GCDDemo[44461:636216] End<br>2017-05-03 17:38:10.894 GCDDemo[44461:636252] 0———并发队列异步执行&lt;NSThread: 0x60800007a700&gt;{number = 4, name = (null)}<br>2017-05-03 17:38:10.894 GCDDemo[44461:636254] 0———并发队列异步执行&lt;NSThread: 0x60800007ac40&gt;{number = 5, name = (null)}<br>2017-05-03 17:38:10.894 GCDDemo[44461:636251] 0———并发队列异步执行&lt;NSThread: 0x60800007a800&gt;{number = 3, name = (null)}<br>2017-05-03 17:38:10.897 GCDDemo[44461:636252] 1———并发队列异步执行&lt;NSThread: 0x60800007a700&gt;{number = 4, name = (null)}<br>2017-05-03 17:38:10.899 GCDDemo[44461:636254] 1———并发队列异步执行&lt;NSThread: 0x60800007ac40&gt;{number = 5, name = (null)}<br>2017-05-03 17:38:10.900 GCDDemo[44461:636251] 1———并发队列异步执行&lt;NSThread: 0x60800007a800&gt;{number = 3, name = (null)}<br>2017-05-03 17:38:10.903 GCDDemo[44461:636252] 2———并发队列异步执行&lt;NSThread: 0x60800007a700&gt;{number = 4, name = (null)}<br>2017-05-03 17:38:10.904 GCDDemo[44461:636254] 2———并发队列异步执行&lt;NSThread: 0x60800007ac40&gt;{number = 5, name = (null)}<br>2017-05-03 17:38:10.905 GCDDemo[44461:636251] 2———并发队列异步执行&lt;NSThread: 0x60800007a800&gt;{number = 3, name = (null)}</p>
</blockquote>
<p><strong>总结: 并发队列异步执行会开辟多线程执行，并且执行顺序不定</strong></p>
<p>各种组合的结果总结如下表</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">同步执行</th>
<th style="text-align:right">异步执行</th>
</tr>
</thead>
<tbody>
<tr>
<td>主线程队列</td>
<td style="text-align:center">出现死锁</td>
<td style="text-align:right">不会开辟多线程，在主线程上串行执行</td>
</tr>
<tr>
<td>串行队列</td>
<td style="text-align:center">不会开辟多线程，在一条线程上串行执行</td>
<td style="text-align:right">不会开辟多线程，在一条线程上串行执行</td>
</tr>
<tr>
<td>并发队列(全局队列)</td>
<td style="text-align:center">不会开辟多线程，在一条线程上串行执行</td>
<td style="text-align:right">开辟多线程执行，并且执行顺序不定</td>
</tr>
</tbody>
</table>
<p><strong>划重点:</strong></p>
<ol>
<li><strong>并发队列只会在异步执行下才会开启多线程执行</strong> </li>
<li><strong>在主线程队列同步执行，或者串行队列嵌套串行队列同步任务会发生死锁</strong> </li>
<li><strong>dispatch_async: 不会阻塞当前队列，立即返回添加当前线程后面任务。</strong></li>
<li><strong>dispatch_sync：会阻塞当前队列，等该sync任务全部执行完毕之后再添加当前队列后面任务</strong></li>
</ol>
<h1 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h1><ol>
<li><p>异步处理数据完成后，主线程更新UI界面</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch\_async(globalQueue, ^&#123;</span><br><span class="line">    //异步数据处理...</span><br><span class="line">    dispatch_async(mainQueue, ^&#123;</span><br><span class="line">        //主线程更新UI</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>可以看到运用GCD可以轻松的进行线程间通信</p>
<ol start="2">
<li><p>使用指定队列进行串行处理任务，例如数据库存储等依赖线程安全等处理</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//串行队列保证线程安全</span><br><span class="line">	dispatch_sync(serialQueue, ^&#123;</span><br><span class="line">	    //数据存储等依赖线程安全操作...</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>FMDBDataBaseQueue就是使用的串行队列来保证线程安全的</p>
<h1 id="其他GCD-API"><a href="#其他GCD-API" class="headerlink" title="其他GCD API"></a>其他GCD API</h1><h2 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a><code>dispatch_after</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time_t time=dispatch_time(DISPATCH_TIME_NOW, 10*NSEC_PER_SEC);</span><br><span class="line">dispatch_after(time, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">	    NSLog(@&quot;After&quot;);</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>
<p>延迟执行，有时候可以作为定时执行作用，需要注意的是，该函数并不是在指定时间后执行处理，而只是在指定时间追加处理到<code>dispatch_queue</code>,实际执行时间受到runloop的状态影响，存在偏差。</p>
<h2 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a><code>dispatch_once</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static dispatch_once_t onceToken;  </span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;  </span><br><span class="line">        sharedManager = [[SchoolManager alloc] init];  </span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>执行一次，在block中的代码全局只会执行一次，被广泛用于单例创建中</p>
<h2 id="dispatch-suspend-dispatch-resume"><a href="#dispatch-suspend-dispatch-resume" class="headerlink" title="dispatch_suspend / dispatch_resume"></a><code>dispatch_suspend / dispatch_resume</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//挂起队列 </span><br><span class="line">dispatch_suspend(queque);</span><br><span class="line">//恢复队列</span><br><span class="line"> dispatch_resume(queue);</span><br></pre></td></tr></table></figure>
<p>挂起对已经执行的任务没有影响，会暂停所有未执行的任务以及后续追加的任务<br>恢复则会继续执行所有被挂起的任务</p>
<h2 id="dispatch-set-target-queue"><a href="#dispatch-set-target-queue" class="headerlink" title="dispatch_set_target_queue"></a><code>dispatch_set_target_queue</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//搬运一段代码</span><br><span class="line">dispatch_queue_t mySerialDispatchQueue =</span><br><span class="line">    dispatch_queue_create(&quot;com.example.gcd.MySerialDispatchQueue&quot;, NULL);</span><br><span class="line">dispatch_queue_t globalDispatchQueueBackground =</span><br><span class="line">    dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);</span><br><span class="line">dispatch_set_target_queue(mySerialDispatchQueue, globalDispatchQueueBackground);</span><br></pre></td></tr></table></figure>
<p>dispatch_set_target_queue主要有两个作用</p>
<ol>
<li>设置优先级，自建的队列优先级默认和系统队列优先级一致，设置参数1队列的优先级和参数2的优先级一致，显然你不能设置系统全局队列和主队列优先级</li>
<li>更改队列的执行层级，如果多个串行队列设置函数目标串行队列是某一个串行队列，原本并发执行的串行队列，在目标串行队列上只能依次执行，代码示例如下</li>
</ol>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t targetQueue = dispatch_queue_create(&quot;test.target.queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_queue_t queue1 = dispatch_queue_create(&quot;test.1&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_queue_t queue2 = dispatch_queue_create(&quot;test.2&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_queue_t queue3 = dispatch_queue_create(&quot;test.3&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_set_target_queue(queue1, targetQueue);</span><br><span class="line">dispatch_set_target_queue(queue2, targetQueue);</span><br><span class="line">dispatch_set_target_queue(queue3, targetQueue);</span><br><span class="line">dispatch_async(queue1, ^&#123;</span><br><span class="line">    NSLog(@&quot;1 in&quot;);</span><br><span class="line">    [NSThread sleepForTimeInterval:3.f];</span><br><span class="line">    NSLog(@&quot;1 out&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue2, ^&#123;</span><br><span class="line">    NSLog(@&quot;2 in&quot;);</span><br><span class="line">    [NSThread sleepForTimeInterval:2.f];</span><br><span class="line">    NSLog(@&quot;2 out&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue3, ^&#123;</span><br><span class="line">    NSLog(@&quot;3 in&quot;);</span><br><span class="line">    [NSThread sleepForTimeInterval:1.f];</span><br><span class="line">    NSLog(@&quot;3 out&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="dispatch-group"><a href="#dispatch-group" class="headerlink" title="dispatch_group"></a><code>dispatch_group</code></h2><p>主要应对这样的需求，异步处理完A和B任务，两者都执行完执行C任务，和NSOperation中的依赖一致。示例如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">   dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">       //异步耗时操作A</span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">       //异步耗时操作B</span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">       // 前面的异步操作A和B都执行完之后，回主线程</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a><code>dispatch_apply</code></h2><p>这是<code>dispatch_sync</code>和<code>dispatch_group</code>的关联API，按指定次数将指定的Block追加到指定的<code>Dispatch_Queue</code>中，并且等待全部执行结束。可以用于遍历效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//全局队列</span><br><span class="line">    dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    dispatch_apply(10, globalQueue, ^(size_t index) &#123;</span><br><span class="line">        //重复执行10次</span><br><span class="line">        NSLog(@&quot;%zu&quot;,index);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    //10次执行完之后，再执行Done</span><br><span class="line">    NSLog(@&quot;Done&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="dispatch-barrier-sync-dispatch-barrier-async"><a href="#dispatch-barrier-sync-dispatch-barrier-async" class="headerlink" title="dispatch_barrier_sync / dispatch_barrier_async"></a><code>dispatch_barrier_sync / dispatch_barrier_async</code></h2><p>栅栏:有时候创建两组并发任务，如果在中间加入栅栏，那么这个任务会在第一组任务完成后执行，并且第二组任务会在栅栏任务完成后才开始执行，如下图所示在并发队列中添加任务，执行顺序一定是<br><strong>任务组A-&gt;Barrier任务-&gt;任务组B</strong></p>
<p>   <img src="http://upload-images.jianshu.io/upload_images/1320629-79295d0d030009a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dispatch_barrier.png"></p>
<p>示例代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;ConcurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">        NSLog(@&quot;1---------&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">        NSLog(@&quot;2--------&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_barrier_async(concurrentQueue, ^&#123;</span><br><span class="line">        NSLog(@&quot;barrier--------&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">        NSLog(@&quot;3--------&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">        NSLog(@&quot;4--------&quot;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>打印执行顺序1，2不定，3，4也不定，但是barrier一定在1和2之后，3和4一定在barrier之后，可以自行添加数量测试。</p>
<p>应用场景，经常我们会自行创建一个队列进行文件读取和存储，一般文件读取的速度很快，可以使用并发队列多线程提高读取效率，但是文件存储需要考虑到线程安全，那么我们就可以使用barrier进行文件存储操作，类似这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;ConcurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">        //文件读取</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">        //文件读取</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_barrier_async(concurrentQueue, ^&#123;</span><br><span class="line">        //文件存储</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_barrier_async(concurrentQueue, ^&#123;</span><br><span class="line">        //文件存储</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">        //文件读取</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>可见使用barrier可以轻松高效的实现文件IO。</p>
<p><strong><code>dispatch_barrier</code>需要注意的点</strong></p>
<ol>
<li><code>dispatch_barrier</code>只会对自建的队列生效，对于系统的mainQueue和GlobalQueue不起作用</li>
<li><code>dispatch_barrier_async</code>和<code>dispatch_barrier_sync</code>的区别也同样在于同步和异步，<code>dispatch_barrier_async</code>不会等待自己任务执行完毕才会在队列中添加其他任务，而<code>dispatch_barrier_sync</code>会等待自己任务执行完毕后才会在队列中添加其他任务。</li>
</ol>
<p>AFNetworking中大量使用<code>dispatch_barrier_async</code>做数据存储，可以看到<code>dispatch_barrier_async</code>也可以实现串行同步队列效果，相比于<code>dispatch_sync</code>容易产生死锁（在串行队列中同步添加该串行队列任务即会发生死锁),<code>dispatch_barrier_async</code>更加安全。</p>
<h1 id="全文总结"><a href="#全文总结" class="headerlink" title="全文总结:"></a>全文总结:</h1><p>以上介绍了GCD中绝大多数常用API，可以看到GCD的灵活性，通过在应用中合理使用GCD来提高程序的执行效率。</p>
<h1 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍:"></a>参考书籍:</h1><p><a href="http://baike.baidu.com/link?url=8cLEWwOe25Y-Fg2wzOTmOmvwn9Osy7tkkNbMKft-fsX0NJlkCXUKsljKkAh2UK0pFb2zm5hL4vs4w6xgMSgWzw2FGCnTTit_hNdQbDOQIHjHs1BW6e4lUl5qARANbVfyNfqEDP_E_aoVC6tR1kLR2K" target="_blank" rel="noopener">Objective-C高级编程</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Ace Dong" />
            
              <p class="site-author-name" itemprop="name">Ace Dong</p>
              <p class="site-description motion-element" itemprop="description">iOS开发者，爱生活，爱编程</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ace Dong</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
