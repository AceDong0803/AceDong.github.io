<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="GCD简介iOS开发中多线程的API主要有pthread，NSThread，NSOperation和GCD，前两者在现在开发过程中已经不常用，NSOperation是面向对象封装的一套API，而GCD则是一套纯C语言API。  引用下百度的介绍GCD为Grand Central Dispatch的缩写。Grand Central Dispatch (GCD)是Apple开发的一个多核编程的较新的解">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS多线程编程之GCD详解（一）">
<meta property="og:url" content="http://yoursite.com/2015/06/03/iOS多线程编程之GCD详解（一）/index.html">
<meta property="og:site_name" content="安东的博客">
<meta property="og:description" content="GCD简介iOS开发中多线程的API主要有pthread，NSThread，NSOperation和GCD，前两者在现在开发过程中已经不常用，NSOperation是面向对象封装的一套API，而GCD则是一套纯C语言API。  引用下百度的介绍GCD为Grand Central Dispatch的缩写。Grand Central Dispatch (GCD)是Apple开发的一个多核编程的较新的解">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1320629-79295d0d030009a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2018-07-18T00:55:59.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS多线程编程之GCD详解（一）">
<meta name="twitter:description" content="GCD简介iOS开发中多线程的API主要有pthread，NSThread，NSOperation和GCD，前两者在现在开发过程中已经不常用，NSOperation是面向对象封装的一套API，而GCD则是一套纯C语言API。  引用下百度的介绍GCD为Grand Central Dispatch的缩写。Grand Central Dispatch (GCD)是Apple开发的一个多核编程的较新的解">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/1320629-79295d0d030009a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2015/06/03/iOS多线程编程之GCD详解（一）/"/>





  <title>iOS多线程编程之GCD详解（一） | 安东的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">安东的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不忘初心，方得始终</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/06/03/iOS多线程编程之GCD详解（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ace Dong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安东的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">iOS多线程编程之GCD详解（一）</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-06-03T15:04:46+08:00">
                2015-06-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS杂货铺/" itemprop="url" rel="index">
                    <span itemprop="name">iOS杂货铺</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="GCD简介"><a href="#GCD简介" class="headerlink" title="GCD简介"></a>GCD简介</h1><p>iOS开发中多线程的API主要有pthread，NSThread，NSOperation和GCD，前两者在现在开发过程中已经不常用，NSOperation是面向对象封装的一套API，而GCD则是一套纯C语言API。</p>
<blockquote>
<p>引用下百度的介绍<br>GCD为Grand Central Dispatch的缩写。<br>Grand Central Dispatch (GCD)是Apple开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并行任务。在Mac OS X 10.6雪豹中首次推出，也可在IOS 4及以上版本使用。</p>
</blockquote>
<p><strong>GCD有哪些优点:</strong></p>
<ol>
<li>提供了易于使用的并发模型而不仅仅只是锁和线程，可以让我们轻松的进行多线程编程。</li>
<li>自动利用更多的CPU内核。</li>
<li>自动管理线程的生命周期，以及多线程调度。</li>
<li>提供了简单创建单例的接口等等。</li>
</ol>
<h1 id="Dispatch-Queue（队列）概念"><a href="#Dispatch-Queue（队列）概念" class="headerlink" title="Dispatch_Queue（队列）概念"></a>Dispatch_Queue（队列）概念</h1><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>GCD中的队列和数据结构中的队列特性上一致，都是受限制的线性表，遵循FIFO(First In First Out),即新的任务需要在队尾加入，读取任务则从队首部读取，即先进先出<br> 队列又分为：</p>
<ul>
<li>串行队列（Serial Dispatch Queue）<br>   简单理解串行队列就是按顺序执行一个任务，上一个任务执行完毕后执行下一个任务，现实中的例子，去银行办业务，只有一个窗口，大家有秩序的排队办业务，即是串行队列</li>
<li>并发队列（Concurrent Dispatch Queue）<br>  简单理解并发队列就是同时执行多个任务，现实中的极端例子，去银行排队办业务，有多个窗口同时可以办业务，即是并发队列，需要注意的是，这些任务会按照被添加的顺序依次开始执行。但是任务完成的顺序是任意的。</li>
</ul>
<p>这里提到了“任务”的概念：<br><strong>“任务”</strong>，在 GCD 里指的是 Block，即一段需要执行的代码块<br>任务执行方式有两种：</p>
<ul>
<li><p>同步执行(dispatch_sync)<br>完成任务后才会返回，进行下一任务，可见同步不具备开启线程能力，只会在当前线程依次执行</p>
</li>
<li><p>异步执行(dispatch_async)<br>完成任务后立即返回，进行下一任务，具备多线程能力</p>
</li>
</ul>
<p><strong>总结：</strong>并发队列只会在异步执行下生效，同步执行不会触发多线程创建。</p>
<h1 id="GCD队列编程实现"><a href="#GCD队列编程实现" class="headerlink" title="GCD队列编程实现"></a>GCD队列编程实现</h1><h2 id="创建一个队列"><a href="#创建一个队列" class="headerlink" title="创建一个队列"></a>创建一个队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//串行队列</span><br><span class="line">    dispatch_queue_t serialQueue = dispatch_queue_create(&quot;serialQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line"> //并发队列</span><br><span class="line">    dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;concurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>
<p> <code>dispatch_queue_create</code></p>
<p>创建一个<code>dispatch_queue_t</code>队列，第一个参数设置该队列标识符，用于调试使用，第二个参数，则是队列类型<br><code>DISPATCH_QUEUE_SERIAL</code>串行队列<br><code>DISPATCH_QUEUE_CONCURRENT</code> 并发队列</p>
<p>除了自己创建队列之外，系统提供了两个队列供我们获取使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//主线程队列</span><br><span class="line">dispatch_queue_t mainQueue = dispatch_get_main_queue();</span><br><span class="line"></span><br><span class="line">//全局队列</span><br><span class="line">dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br></pre></td></tr></table></figure>
<ul>
<li>主线程队列：这个是主线程的串行队列</li>
<li>全局队列: 这是个全局的并发队列，很多时候可以不需要自己创建并发队列，直接获取全局队列即可 第一个参数为优先级，这是个大概优先级设置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_QUEUE_PRIORITY_HIGH  //高优先级</span><br><span class="line">DISPATCH_QUEUE_PRIORITY_DEFAULT //默认优先级</span><br><span class="line">DISPATCH_QUEUE_PRIORITY_LOW //低优先级</span><br><span class="line">DISPATCH_QUEUE_PRIORITY_BACKGROUND //后台优先级</span><br></pre></td></tr></table></figure>
<p>接下来即可在队列中添加任务执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//异步执行</span><br><span class="line">dispatch_async(serialQueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;serialQueue中异步执行&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">	</span><br><span class="line">//同步执行</span><br><span class="line">dispatch_sync(serialQueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;serialQueue中同步执行&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里总共有三种类型队列：</p>
<ol>
<li>并发队列（包括全局队列）</li>
<li>串行队列</li>
<li>主线程队列 </li>
</ol>
<p>三种队列分别可以同步异步执行就有6种组合方式</p>
<ul>
<li>主线程同步执行</li>
<li>主线程异步执行</li>
<li>串行队列同步执行</li>
<li>串行队列异步执行</li>
<li>并行队列同步执行</li>
<li>并行队列异步执行</li>
</ul>
<p>接下来我们依次看下每种情况</p>
<h2 id="主线程同步执行"><a href="#主线程同步执行" class="headerlink" title="主线程同步执行"></a>主线程同步执行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;Begin&quot;);</span><br><span class="line">	</span><br><span class="line">//主线程同步同步执行</span><br><span class="line">dispatch_sync(mainQueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;主线程同步同步执行&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">	</span><br><span class="line">NSLog(@&quot;End&quot;);</span><br></pre></td></tr></table></figure>
<p>运行下我们会发现</p>
<blockquote>
<p>2017-05-03 16:50:31.542 GCDDemo[41489:596607] Begin<br>只打印了begin，并没有执行下去<br>事实上这里发生了死锁，<br>之前说过<code>dispatch_sync</code>会等待上一个任务执行完才会执行下一个任务，sync添加的任务需要执行，需要等待<code>NSLog(@&quot;End&quot;);</code>执行完毕，<code>NSLog(@&quot;End&quot;);</code>任务本身也添加在主线程队列中，所以执行这个任务的前提是sync添加的任务执行完毕，这就出现了死锁，两个任务互相等待</p>
</blockquote>
<p> <strong>总结</strong>:</p>
<ol>
<li><strong>主线程中执行同步任务会发生死锁</strong></li>
<li><strong>串行队列中嵌套串行队列任务会发生死锁(这个留给大家自己验证，本质上和主线程同步发生死锁一致)</strong></li>
</ol>
<h2 id="主线程异步执行"><a href="#主线程异步执行" class="headerlink" title="主线程异步执行"></a>主线程异步执行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;Begin&quot;);</span><br><span class="line">//主线程异步执行</span><br><span class="line">dispatch_async(mainQueue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">       NSLog(@&quot;%d---------主线程异步执行%@&quot;, i,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(mainQueue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">        NSLog(@&quot;%d---------主线程异步执行%@&quot;, i,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(mainQueue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">        NSLog(@&quot;%d---------主线程异步执行%@&quot;, i,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;End&quot;);</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<blockquote>
<p>2017-05-03 17:09:26.031 GCDDemo[42671:613068] Begin<br>2017-05-03 17:09:26.031 GCDDemo[42671:613068] End<br>2017-05-03 17:09:26.042 GCDDemo[42671:613068] 0———主线程异步执行&lt;NSThread: 0x60000007d5c0&gt;{number = 1, name = main}<br>2017-05-03 17:09:26.043 GCDDemo[42671:613068] 1———主线程异步执行&lt;NSThread: 0x60000007d5c0&gt;{number = 1, name = main}<br>2017-05-03 17:09:26.044 GCDDemo[42671:613068] 2———主线程异步执行&lt;NSThread: 0x60000007d5c0&gt;{number = 1, name = main}<br>2017-05-03 17:09:26.052 GCDDemo[42671:613068] 0———主线程异步执行&lt;NSThread: 0x60000007d5c0&gt;{number = 1, name = main}<br>2017-05-03 17:09:26.057 GCDDemo[42671:613068] 1———主线程异步执行&lt;NSThread: 0x60000007d5c0&gt;{number = 1, name = main}<br>2017-05-03 17:09:26.059 GCDDemo[42671:613068] 2———主线程异步执行&lt;NSThread: 0x60000007d5c0&gt;{number = 1, name = main}<br>2017-05-03 17:09:26.060 GCDDemo[42671:613068] 0———主线程异步执行&lt;NSThread: 0x60000007d5c0&gt;{number = 1, name = main}<br>2017-05-03 17:09:26.062 GCDDemo[42671:613068] 1———主线程异步执行&lt;NSThread: 0x60000007d5c0&gt;{number = 1, name = main}<br>2017-05-03 17:09:26.063 GCDDemo[42671:613068] 2———主线程异步执行&lt;NSThread: 0x60000007d5c0&gt;{number = 1, name = main}</p>
</blockquote>
<p><strong>总结:</strong></p>
<p><strong>主线程队列异步执行不会开辟线程，会在当前线程同步执行。</strong></p>
<h2 id="串行队列同步执行"><a href="#串行队列同步执行" class="headerlink" title="串行队列同步执行"></a>串行队列同步执行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;Begin&quot;);</span><br><span class="line">//串行队列同步执行</span><br><span class="line">dispatch_sync(serialQueue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">       NSLog(@&quot;%d---------串行队列同步执行%@&quot;, i,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_sync(serialQueue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">        NSLog(@&quot;%d---------串行队列同步执行%@&quot;, i,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_sync(serialQueue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">        NSLog(@&quot;%d---------串行队列同步执行%@&quot;, i,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;End&quot;);</span><br></pre></td></tr></table></figure>
<p>运行结果如下: </p>
<blockquote>
<p>2017-05-03 17:25:48.225 GCDDemo[43694:625941] Begin<br>2017-05-03 17:25:48.225 GCDDemo[43694:625941] 0———串行队列同步执行&lt;NSThread: 0x60800007f880&gt;{number = 1, name = main}<br>2017-05-03 17:25:48.226 GCDDemo[43694:625941] 1———串行队列同步执行&lt;NSThread: 0x60800007f880&gt;{number = 1, name = main}<br>2017-05-03 17:25:48.226 GCDDemo[43694:625941] 2———串行队列同步执行&lt;NSThread: 0x60800007f880&gt;{number = 1, name = main}<br>2017-05-03 17:25:48.226 GCDDemo[43694:625941] 0———串行队列同步执行&lt;NSThread: 0x60800007f880&gt;{number = 1, name = main}<br>2017-05-03 17:25:48.227 GCDDemo[43694:625941] 1———串行队列同步执行&lt;NSThread: 0x60800007f880&gt;{number = 1, name = main}<br>2017-05-03 17:25:48.227 GCDDemo[43694:625941] 2———串行队列同步执行&lt;NSThread: 0x60800007f880&gt;{number = 1, name = main}<br>2017-05-03 17:25:48.227 GCDDemo[43694:625941] 0———串行队列同步执行&lt;NSThread: 0x60800007f880&gt;{number = 1, name = main}<br>2017-05-03 17:25:48.228 GCDDemo[43694:625941] 1———串行队列同步执行&lt;NSThread: 0x60800007f880&gt;{number = 1, name = main}<br>2017-05-03 17:25:48.228 GCDDemo[43694:625941] 2———串行队列同步执行&lt;NSThread: 0x60800007f880&gt;{number = 1, name = main}<br>2017-05-03 17:25:48.228 GCDDemo[43694:625941] End</p>
</blockquote>
<p><strong>总结: 串行队列异步执行不会开辟多线程，只会在一条线程中依次执行</strong></p>
<h2 id="串行队列异步执行"><a href="#串行队列异步执行" class="headerlink" title="串行队列异步执行"></a>串行队列异步执行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;Begin&quot;);</span><br><span class="line">//串行队列异步执行</span><br><span class="line">dispatch_async(serialQueue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">       NSLog(@&quot;%d---------串行队列异步执行%@&quot;, i,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(serialQueue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">        NSLog(@&quot;%d---------串行队列异步执行%@&quot;, i,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch\_async(serialQueue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">        NSLog(@&quot;%d---------串行队列异步执行%@&quot;, i,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;End&quot;);</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<blockquote>
<p>2017-05-03 17:20:16.514 GCDDemo[43349:621375] Begin<br>2017-05-03 17:20:16.514 GCDDemo[43349:621375] End<br>2017-05-03 17:20:16.515 GCDDemo[43349:621680] 0———串行队列异步执行&lt;NSThread: 0x608000268040&gt;{number = 3, name = (null)}<br>2017-05-03 17:20:16.515 GCDDemo[43349:621680] 1———串行队列同步执行&lt;NSThread: 0x608000268040&gt;{number = 3, name = (null)}<br>2017-05-03 17:20:16.515 GCDDemo[43349:621680] 2———串行队列异步执行&lt;NSThread: 0x608000268040&gt;{number = 3, name = (null)}<br>2017-05-03 17:20:16.516 GCDDemo[43349:621680] 0———串行队列异步执行&lt;NSThread: 0x608000268040&gt;{number = 3, name = (null)}<br>2017-05-03 17:20:16.516 GCDDemo[43349:621680] 1———串行队列异步执行&lt;NSThread: 0x608000268040&gt;{number = 3, name = (null)}<br>2017-05-03 17:20:16.516 GCDDemo[43349:621680] 2———串行队列异步执行&lt;NSThread: 0x608000268040&gt;{number = 3, name = (null)}<br>2017-05-03 17:20:16.516 GCDDemo[43349:621680] 0———串行队列异步执行&lt;NSThread: 0x608000268040&gt;{number = 3, name = (null)}<br>2017-05-03 17:20:16.517 GCDDemo[43349:621680] 1———串行队列异步执行&lt;NSThread: 0x608000268040&gt;{number = 3, name = (null)}<br>2017-05-03 17:20:16.517 GCDDemo[43349:621680] 2———串行队列异步执行&lt;NSThread: 0x608000268040&gt;{number = 3, name = (null)}</p>
</blockquote>
<p><strong>总结: 串行队列异步执行不会开辟多线程，只会在一条线程中依次执行</strong></p>
<p>细心的同学会发现串行队列同步和异步执行都没有开辟多线程，在一条线程中同步执行，那么对于串行队列同步和异步执行有什么区别呢?<br>区别只有一点：</p>
<p>dispatch_async：<strong>不会阻塞当前队列</strong>，立即返回添加当前队列后面任务，可以看到上图打印结果，先打印end。再打印async任务</p>
<p>dispatch_sync：<strong>会阻塞当前队列</strong>，等该sync任务全部执行完毕之后再添加当前队列后面任务，可以看到上图打印结果，先打印完sync任务打印end。</p>
<h2 id="并发队列同步执行"><a href="#并发队列同步执行" class="headerlink" title="并发队列同步执行"></a>并发队列同步执行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;Begin&quot;);</span><br><span class="line">//串行队列同步执行</span><br><span class="line">dispatch_sync(concurrentQueue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">       NSLog(@&quot;%d---------并发队列同步执行%@&quot;, i,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_sync(concurrentQueue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">        NSLog(@&quot;%d---------并发队列同步执行%@&quot;, i,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_sync(concurrentQueue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">        NSLog(@&quot;%d---------并发队列同步执行%@&quot;, i,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;End&quot;);</span><br></pre></td></tr></table></figure>
<p>运行结果如下:</p>
<blockquote>
<p>2017-05-03 17:34:24.407 GCDDemo[44222:633000] Begin<br>2017-05-03 17:34:24.407 GCDDemo[44222:633000] 0———并发队列同步执行&lt;NSThread: 0x60800006f380&gt;{number = 1, name = main}<br>2017-05-03 17:34:24.407 GCDDemo[44222:633000] 1———并发队列同步执行&lt;NSThread: 0x60800006f380&gt;{number = 1, name = main}<br>2017-05-03 17:34:24.408 GCDDemo[44222:633000] 2———并发队列同步执行&lt;NSThread: 0x60800006f380&gt;{number = 1, name = main}<br>2017-05-03 17:34:24.408 GCDDemo[44222:633000] 0———并发队列同步执行&lt;NSThread: 0x60800006f380&gt;{number = 1, name = main}<br>2017-05-03 17:34:24.408 GCDDemo[44222:633000] 1———并发队列同步执行&lt;NSThread: 0x60800006f380&gt;{number = 1, name = main}<br>2017-05-03 17:34:24.408 GCDDemo[44222:633000] 2———并发队列同步执行&lt;NSThread: 0x60800006f380&gt;{number = 1, name = main}<br>2017-05-03 17:34:24.408 GCDDemo[44222:633000] 0———并发队列同步执行&lt;NSThread: 0x60800006f380&gt;{number = 1, name = main}<br>2017-05-03 17:34:24.408 GCDDemo[44222:633000] 1———并发队列同步执行&lt;NSThread: 0x60800006f380&gt;{number = 1, name = main}<br>2017-05-03 17:34:24.409 GCDDemo[44222:633000] 2———并发队列同步执行&lt;NSThread: 0x60800006f380&gt;{number = 1, name = main}<br>2017-05-03 17:34:24.410 GCDDemo[44222:633000] End</p>
</blockquote>
<p><strong>总结: 并发队列同步执行不会开辟多线程，只会在一条线程中依次执行</strong></p>
<h2 id="并发队列异步执行"><a href="#并发队列异步执行" class="headerlink" title="并发队列异步执行"></a>并发队列异步执行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;Begin&quot;);</span><br><span class="line">//并发队列异步执行</span><br><span class="line">dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">       NSLog(@&quot;%d---------并发队列异步执行%@&quot;, i,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">        NSLog(@&quot;%d---------并发队列异步执行%@&quot;, i,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 3; i ++) &#123;</span><br><span class="line">        NSLog(@&quot;%d---------并发队列异步执行%@&quot;, i,[NSThread currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;End&quot;);</span><br></pre></td></tr></table></figure>
<p>运行结果如下</p>
<blockquote>
<p>2017-05-03 17:38:10.893 GCDDemo[44461:636216] Begin<br>2017-05-03 17:38:10.894 GCDDemo[44461:636216] End<br>2017-05-03 17:38:10.894 GCDDemo[44461:636252] 0———并发队列异步执行&lt;NSThread: 0x60800007a700&gt;{number = 4, name = (null)}<br>2017-05-03 17:38:10.894 GCDDemo[44461:636254] 0———并发队列异步执行&lt;NSThread: 0x60800007ac40&gt;{number = 5, name = (null)}<br>2017-05-03 17:38:10.894 GCDDemo[44461:636251] 0———并发队列异步执行&lt;NSThread: 0x60800007a800&gt;{number = 3, name = (null)}<br>2017-05-03 17:38:10.897 GCDDemo[44461:636252] 1———并发队列异步执行&lt;NSThread: 0x60800007a700&gt;{number = 4, name = (null)}<br>2017-05-03 17:38:10.899 GCDDemo[44461:636254] 1———并发队列异步执行&lt;NSThread: 0x60800007ac40&gt;{number = 5, name = (null)}<br>2017-05-03 17:38:10.900 GCDDemo[44461:636251] 1———并发队列异步执行&lt;NSThread: 0x60800007a800&gt;{number = 3, name = (null)}<br>2017-05-03 17:38:10.903 GCDDemo[44461:636252] 2———并发队列异步执行&lt;NSThread: 0x60800007a700&gt;{number = 4, name = (null)}<br>2017-05-03 17:38:10.904 GCDDemo[44461:636254] 2———并发队列异步执行&lt;NSThread: 0x60800007ac40&gt;{number = 5, name = (null)}<br>2017-05-03 17:38:10.905 GCDDemo[44461:636251] 2———并发队列异步执行&lt;NSThread: 0x60800007a800&gt;{number = 3, name = (null)}</p>
</blockquote>
<p><strong>总结: 并发队列异步执行会开辟多线程执行，并且执行顺序不定</strong></p>
<p>各种组合的结果总结如下表</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">同步执行</th>
<th style="text-align:right">异步执行</th>
</tr>
</thead>
<tbody>
<tr>
<td>主线程队列</td>
<td style="text-align:center">出现死锁</td>
<td style="text-align:right">不会开辟多线程，在主线程上串行执行</td>
</tr>
<tr>
<td>串行队列</td>
<td style="text-align:center">不会开辟多线程，在一条线程上串行执行</td>
<td style="text-align:right">不会开辟多线程，在一条线程上串行执行</td>
</tr>
<tr>
<td>并发队列(全局队列)</td>
<td style="text-align:center">不会开辟多线程，在一条线程上串行执行</td>
<td style="text-align:right">开辟多线程执行，并且执行顺序不定</td>
</tr>
</tbody>
</table>
<p><strong>划重点:</strong></p>
<ol>
<li><strong>并发队列只会在异步执行下才会开启多线程执行</strong> </li>
<li><strong>在主线程队列同步执行，或者串行队列嵌套串行队列同步任务会发生死锁</strong> </li>
<li><strong>dispatch_async: 不会阻塞当前队列，立即返回添加当前线程后面任务。</strong></li>
<li><strong>dispatch_sync：会阻塞当前队列，等该sync任务全部执行完毕之后再添加当前队列后面任务</strong></li>
</ol>
<h1 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h1><ol>
<li><p>异步处理数据完成后，主线程更新UI界面</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch\_async(globalQueue, ^&#123;</span><br><span class="line">    //异步数据处理...</span><br><span class="line">    dispatch_async(mainQueue, ^&#123;</span><br><span class="line">        //主线程更新UI</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>可以看到运用GCD可以轻松的进行线程间通信</p>
<ol start="2">
<li><p>使用指定队列进行串行处理任务，例如数据库存储等依赖线程安全等处理</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//串行队列保证线程安全</span><br><span class="line">	dispatch_sync(serialQueue, ^&#123;</span><br><span class="line">	    //数据存储等依赖线程安全操作...</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>FMDBDataBaseQueue就是使用的串行队列来保证线程安全的</p>
<h1 id="其他GCD-API"><a href="#其他GCD-API" class="headerlink" title="其他GCD API"></a>其他GCD API</h1><h2 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a><code>dispatch_after</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time_t time=dispatch_time(DISPATCH_TIME_NOW, 10*NSEC_PER_SEC);</span><br><span class="line">dispatch_after(time, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">	    NSLog(@&quot;After&quot;);</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>
<p>延迟执行，有时候可以作为定时执行作用，需要注意的是，该函数并不是在指定时间后执行处理，而只是在指定时间追加处理到<code>dispatch_queue</code>,实际执行时间受到runloop的状态影响，存在偏差。</p>
<h2 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a><code>dispatch_once</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static dispatch_once_t onceToken;  </span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;  </span><br><span class="line">        sharedManager = [[SchoolManager alloc] init];  </span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>执行一次，在block中的代码全局只会执行一次，被广泛用于单例创建中</p>
<h2 id="dispatch-suspend-dispatch-resume"><a href="#dispatch-suspend-dispatch-resume" class="headerlink" title="dispatch_suspend / dispatch_resume"></a><code>dispatch_suspend / dispatch_resume</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//挂起队列 </span><br><span class="line">dispatch_suspend(queque);</span><br><span class="line">//恢复队列</span><br><span class="line"> dispatch_resume(queue);</span><br></pre></td></tr></table></figure>
<p>挂起对已经执行的任务没有影响，会暂停所有未执行的任务以及后续追加的任务<br>恢复则会继续执行所有被挂起的任务</p>
<h2 id="dispatch-set-target-queue"><a href="#dispatch-set-target-queue" class="headerlink" title="dispatch_set_target_queue"></a><code>dispatch_set_target_queue</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//搬运一段代码</span><br><span class="line">dispatch_queue_t mySerialDispatchQueue =</span><br><span class="line">    dispatch_queue_create(&quot;com.example.gcd.MySerialDispatchQueue&quot;, NULL);</span><br><span class="line">dispatch_queue_t globalDispatchQueueBackground =</span><br><span class="line">    dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);</span><br><span class="line">dispatch_set_target_queue(mySerialDispatchQueue, globalDispatchQueueBackground);</span><br></pre></td></tr></table></figure>
<p>dispatch_set_target_queue主要有两个作用</p>
<ol>
<li>设置优先级，自建的队列优先级默认和系统队列优先级一致，设置参数1队列的优先级和参数2的优先级一致，显然你不能设置系统全局队列和主队列优先级</li>
<li>更改队列的执行层级，如果多个串行队列设置函数目标串行队列是某一个串行队列，原本并发执行的串行队列，在目标串行队列上只能依次执行，代码示例如下</li>
</ol>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t targetQueue = dispatch_queue_create(&quot;test.target.queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_queue_t queue1 = dispatch_queue_create(&quot;test.1&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_queue_t queue2 = dispatch_queue_create(&quot;test.2&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_queue_t queue3 = dispatch_queue_create(&quot;test.3&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_set_target_queue(queue1, targetQueue);</span><br><span class="line">dispatch_set_target_queue(queue2, targetQueue);</span><br><span class="line">dispatch_set_target_queue(queue3, targetQueue);</span><br><span class="line">dispatch_async(queue1, ^&#123;</span><br><span class="line">    NSLog(@&quot;1 in&quot;);</span><br><span class="line">    [NSThread sleepForTimeInterval:3.f];</span><br><span class="line">    NSLog(@&quot;1 out&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue2, ^&#123;</span><br><span class="line">    NSLog(@&quot;2 in&quot;);</span><br><span class="line">    [NSThread sleepForTimeInterval:2.f];</span><br><span class="line">    NSLog(@&quot;2 out&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue3, ^&#123;</span><br><span class="line">    NSLog(@&quot;3 in&quot;);</span><br><span class="line">    [NSThread sleepForTimeInterval:1.f];</span><br><span class="line">    NSLog(@&quot;3 out&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="dispatch-group"><a href="#dispatch-group" class="headerlink" title="dispatch_group"></a><code>dispatch_group</code></h2><p>主要应对这样的需求，异步处理完A和B任务，两者都执行完执行C任务，和NSOperation中的依赖一致。示例如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">   dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">       //异步耗时操作A</span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">       //异步耗时操作B</span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">       // 前面的异步操作A和B都执行完之后，回主线程</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a><code>dispatch_apply</code></h2><p>这是<code>dispatch_sync</code>和<code>dispatch_group</code>的关联API，按指定次数将指定的Block追加到指定的<code>Dispatch_Queue</code>中，并且等待全部执行结束。可以用于遍历效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//全局队列</span><br><span class="line">    dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    dispatch_apply(10, globalQueue, ^(size_t index) &#123;</span><br><span class="line">        //重复执行10次</span><br><span class="line">        NSLog(@&quot;%zu&quot;,index);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    //10次执行完之后，再执行Done</span><br><span class="line">    NSLog(@&quot;Done&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="dispatch-barrier-sync-dispatch-barrier-async"><a href="#dispatch-barrier-sync-dispatch-barrier-async" class="headerlink" title="dispatch_barrier_sync / dispatch_barrier_async"></a><code>dispatch_barrier_sync / dispatch_barrier_async</code></h2><p>栅栏:有时候创建两组并发任务，如果在中间加入栅栏，那么这个任务会在第一组任务完成后执行，并且第二组任务会在栅栏任务完成后才开始执行，如下图所示在并发队列中添加任务，执行顺序一定是<br><strong>任务组A-&gt;Barrier任务-&gt;任务组B</strong></p>
<p>   <img src="http://upload-images.jianshu.io/upload_images/1320629-79295d0d030009a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dispatch_barrier.png"></p>
<p>示例代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;ConcurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">        NSLog(@&quot;1---------&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">        NSLog(@&quot;2--------&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_barrier_async(concurrentQueue, ^&#123;</span><br><span class="line">        NSLog(@&quot;barrier--------&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">        NSLog(@&quot;3--------&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">        NSLog(@&quot;4--------&quot;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>打印执行顺序1，2不定，3，4也不定，但是barrier一定在1和2之后，3和4一定在barrier之后，可以自行添加数量测试。</p>
<p>应用场景，经常我们会自行创建一个队列进行文件读取和存储，一般文件读取的速度很快，可以使用并发队列多线程提高读取效率，但是文件存储需要考虑到线程安全，那么我们就可以使用barrier进行文件存储操作，类似这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;ConcurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">        //文件读取</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">        //文件读取</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_barrier_async(concurrentQueue, ^&#123;</span><br><span class="line">        //文件存储</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_barrier_async(concurrentQueue, ^&#123;</span><br><span class="line">        //文件存储</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(concurrentQueue, ^&#123;</span><br><span class="line">        //文件读取</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>可见使用barrier可以轻松高效的实现文件IO。</p>
<p><strong><code>dispatch_barrier</code>需要注意的点</strong></p>
<ol>
<li><code>dispatch_barrier</code>只会对自建的队列生效，对于系统的mainQueue和GlobalQueue不起作用</li>
<li><code>dispatch_barrier_async</code>和<code>dispatch_barrier_sync</code>的区别也同样在于同步和异步，<code>dispatch_barrier_async</code>不会等待自己任务执行完毕才会在队列中添加其他任务，而<code>dispatch_barrier_sync</code>会等待自己任务执行完毕后才会在队列中添加其他任务。</li>
</ol>
<p>AFNetworking中大量使用<code>dispatch_barrier_async</code>做数据存储，可以看到<code>dispatch_barrier_async</code>也可以实现串行同步队列效果，相比于<code>dispatch_sync</code>容易产生死锁（在串行队列中同步添加该串行队列任务即会发生死锁),<code>dispatch_barrier_async</code>更加安全。</p>
<h1 id="全文总结"><a href="#全文总结" class="headerlink" title="全文总结:"></a>全文总结:</h1><p>以上介绍了GCD中绝大多数常用API，可以看到GCD的灵活性，通过在应用中合理使用GCD来提高程序的执行效率。</p>
<h1 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍:"></a>参考书籍:</h1><p><a href="http://baike.baidu.com/link?url=8cLEWwOe25Y-Fg2wzOTmOmvwn9Osy7tkkNbMKft-fsX0NJlkCXUKsljKkAh2UK0pFb2zm5hL4vs4w6xgMSgWzw2FGCnTTit_hNdQbDOQIHjHs1BW6e4lUl5qARANbVfyNfqEDP_E_aoVC6tR1kLR2K" target="_blank" rel="noopener">Objective-C高级编程</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/06/10/iOS多线程编程之GCD详解（二）完结/" rel="prev" title="iOS多线程编程之GCD详解（二）">
                iOS多线程编程之GCD详解（二） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Ace Dong" />
            
              <p class="site-author-name" itemprop="name">Ace Dong</p>
              <p class="site-description motion-element" itemprop="description">iOS开发者，爱生活，爱编程</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/AceDong0803" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/5a75a6186fb9a063592ba9d2/posts" target="_blank" title="juejin">
                      
                        <i class="fa fa-fw fa-globe"></i>juejin</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#GCD简介"><span class="nav-number">1.</span> <span class="nav-text">GCD简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Dispatch-Queue（队列）概念"><span class="nav-number">2.</span> <span class="nav-text">Dispatch_Queue（队列）概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#队列"><span class="nav-number">2.1.</span> <span class="nav-text">队列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GCD队列编程实现"><span class="nav-number">3.</span> <span class="nav-text">GCD队列编程实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建一个队列"><span class="nav-number">3.1.</span> <span class="nav-text">创建一个队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主线程同步执行"><span class="nav-number">3.2.</span> <span class="nav-text">主线程同步执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主线程异步执行"><span class="nav-number">3.3.</span> <span class="nav-text">主线程异步执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#串行队列同步执行"><span class="nav-number">3.4.</span> <span class="nav-text">串行队列同步执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#串行队列异步执行"><span class="nav-number">3.5.</span> <span class="nav-text">串行队列异步执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并发队列同步执行"><span class="nav-number">3.6.</span> <span class="nav-text">并发队列同步执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并发队列异步执行"><span class="nav-number">3.7.</span> <span class="nav-text">并发队列异步执行</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#应用示例"><span class="nav-number">4.</span> <span class="nav-text">应用示例</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#其他GCD-API"><span class="nav-number">5.</span> <span class="nav-text">其他GCD API</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#dispatch-after"><span class="nav-number">5.1.</span> <span class="nav-text">dispatch_after</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dispatch-once"><span class="nav-number">5.2.</span> <span class="nav-text">dispatch_once</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dispatch-suspend-dispatch-resume"><span class="nav-number">5.3.</span> <span class="nav-text">dispatch_suspend / dispatch_resume</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dispatch-set-target-queue"><span class="nav-number">5.4.</span> <span class="nav-text">dispatch_set_target_queue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dispatch-group"><span class="nav-number">5.5.</span> <span class="nav-text">dispatch_group</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dispatch-apply"><span class="nav-number">5.6.</span> <span class="nav-text">dispatch_apply</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dispatch-barrier-sync-dispatch-barrier-async"><span class="nav-number">5.7.</span> <span class="nav-text">dispatch_barrier_sync / dispatch_barrier_async</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#全文总结"><span class="nav-number">6.</span> <span class="nav-text">全文总结:</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考书籍"><span class="nav-number">7.</span> <span class="nav-text">参考书籍:</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ace Dong</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
